============================= DIRECTORY OVERVIEW =============================
Root: C:\Projects\sense-pi-local-recording-live\to_be_integrated
Timestamp: 24/11/2025 23:14:05.14

----------------------------- TREE (with files) -----------------------------
Folder PATH listing for volume Windows-SSD
Volume serial number is 60BC-E58B
C:\PROJECTS\SENSE-PI-LOCAL-RECORDING-LIVE\TO_BE_INTEGRATED
¦   app.py
¦   combine.bat
¦   combined.py
¦   requirements.txt
¦   __init__.py
¦   
+---core
¦       models.py
¦       state.py
¦       __init__.py
¦       
+---data
¦       base.py
¦       live_reader.py
¦       mqtt_source.py
¦       
+---Images
¦       sensors.jpg
¦       
+---plotting
¦       plotter.py
¦       __init__.py
¦       
+---sonify
¦   ¦   notes_method.py
¦   ¦   
¦   +---utils
¦           audio.py
¦           dsp.py
¦           __init__.py
¦           
+---tests
¦       smoke_signals.py
¦       test_sampling.py
¦       __init__.py
¦       
+---ui
¦   ¦   fft_view.py
¦   ¦   main_window.py
¦   ¦   styles.py
¦   ¦   tab_fft.py
¦   ¦   tab_recorder.py
¦   ¦   tab_signals.py
¦   ¦   widgets.py
¦   ¦   __init__.py
¦   ¦   
¦   +---recorder
¦           capture_tab.py
¦           fft_tab.py
¦           split_csv_tab.py
¦           view_csv_tab.py
¦           __init__.py
¦           
+---util
    ¦   calibration.py
    ¦   ringbuf.py
    ¦   __init__.py
    ¦   
    +---__pycache__
            calibration.cpython-311.pyc
            calibration.cpython-312.pyc
            ringbuf.cpython-311.pyc
            ringbuf.cpython-312.pyc
            __init__.cpython-311.pyc
            __init__.cpython-312.pyc
            

------------------------- DETAILED DIRECTORY LISTING -------------------------
 Volume in drive C is Windows-SSD
 Volume Serial Number is 60BC-E58B

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated

24/11/2025  23:14    <DIR>          .
24/11/2025  23:02    <DIR>          ..
21/09/2025  00:09               619 app.py
21/11/2025  11:42             2,393 combine.bat
24/11/2025  23:14             1,794 combined.py
24/11/2025  23:06    <DIR>          core
24/11/2025  23:07    <DIR>          data
24/11/2025  23:07    <DIR>          Images
24/11/2025  23:08    <DIR>          plotting
25/09/2025  08:39               413 requirements.txt
24/11/2025  23:08    <DIR>          sonify
24/11/2025  23:06    <DIR>          tests
24/11/2025  23:09    <DIR>          ui
24/11/2025  23:09    <DIR>          util
16/09/2025  08:39                60 __init__.py
               5 File(s)          5,279 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\core

24/11/2025  23:06    <DIR>          .
24/11/2025  23:14    <DIR>          ..
29/09/2025  11:58               968 models.py
16/09/2025  18:16             1,573 state.py
16/09/2025  08:39                65 __init__.py
               3 File(s)          2,606 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\data

24/11/2025  23:07    <DIR>          .
24/11/2025  23:14    <DIR>          ..
16/09/2025  08:39             2,366 base.py
16/09/2025  13:37               677 live_reader.py
16/11/2025  12:16            16,378 mqtt_source.py
               3 File(s)         19,421 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\Images

24/11/2025  23:07    <DIR>          .
24/11/2025  23:14    <DIR>          ..
24/11/2025  23:07                12 sensors.jpg
               1 File(s)             12 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\plotting

24/11/2025  23:08    <DIR>          .
24/11/2025  23:14    <DIR>          ..
16/09/2025  13:15             1,521 plotter.py
16/09/2025  08:39                48 __init__.py
               2 File(s)          1,569 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\sonify

24/11/2025  23:08    <DIR>          .
24/11/2025  23:14    <DIR>          ..
18/09/2025  07:31            14,150 notes_method.py
24/11/2025  23:08    <DIR>          utils
               1 File(s)         14,150 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\sonify\utils

24/11/2025  23:08    <DIR>          .
24/11/2025  23:08    <DIR>          ..
18/09/2025  13:39               639 audio.py
19/09/2025  02:09             2,045 dsp.py
18/09/2025  13:41                94 __init__.py
               3 File(s)          2,778 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\tests

24/11/2025  23:06    <DIR>          .
24/11/2025  23:14    <DIR>          ..
16/09/2025  08:39               740 smoke_signals.py
16/11/2025  12:16             1,207 test_sampling.py
16/09/2025  08:39                42 __init__.py
               3 File(s)          1,989 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\ui

24/11/2025  23:09    <DIR>          .
24/11/2025  23:14    <DIR>          ..
19/09/2025  03:24             5,534 fft_view.py
25/09/2025  08:49             2,838 main_window.py
24/11/2025  23:08    <DIR>          recorder
16/09/2025  08:39               775 styles.py
25/09/2025  09:53            10,945 tab_fft.py
29/09/2025  11:07             1,213 tab_recorder.py
16/11/2025  12:16            12,069 tab_signals.py
16/09/2025  13:10             2,709 widgets.py
29/09/2025  11:08                59 __init__.py
               8 File(s)         36,142 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\ui\recorder

24/11/2025  23:08    <DIR>          .
24/11/2025  23:09    <DIR>          ..
16/11/2025  12:16            20,240 capture_tab.py
29/09/2025  11:51            11,900 fft_tab.py
29/09/2025  11:49             8,171 split_csv_tab.py
29/09/2025  11:47             9,848 view_csv_tab.py
29/09/2025  10:50                40 __init__.py
               5 File(s)         50,199 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\util

24/11/2025  23:09    <DIR>          .
24/11/2025  23:14    <DIR>          ..
18/09/2025  10:43               856 calibration.py
16/09/2025  08:39             1,825 ringbuf.py
16/09/2025  08:39                47 __init__.py
24/11/2025  23:06    <DIR>          __pycache__
               3 File(s)          2,728 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\util\__pycache__

24/11/2025  23:06    <DIR>          .
24/11/2025  23:09    <DIR>          ..
18/09/2025  10:56             1,533 calibration.cpython-311.pyc
20/09/2025  20:49             1,392 calibration.cpython-312.pyc
16/09/2025  11:17             3,431 ringbuf.cpython-311.pyc
20/09/2025  20:49             3,213 ringbuf.cpython-312.pyc
16/09/2025  11:17               244 __init__.cpython-311.pyc
20/09/2025  20:49               176 __init__.cpython-312.pyc
               6 File(s)          9,989 bytes

     Total Files Listed:
              43 File(s)        146,862 bytes
              35 Dir(s)  30,257,192,960 bytes free

============================================================================

============================= __init__.py
# File: __init__.py (ext: .py
# Dir : 
# Size: 60 bytes
# Time: 16/09/2025 08:39
============================= __init__.py
"""Root package for the Digital Twin Simple application."""

------------------------------ END OF FILE ------------------------------

============================= app.py
# File: app.py (ext: .py
# Dir : 
# Size: 619 bytes
# Time: 21/09/2025 00:09
============================= app.py
from __future__ import annotations
import os, sys, atexit

# Keep these if you like, they don't hurt:
os.environ.setdefault("SDL_AUDIODRIVER", "dummy")

try:
    import sdl3
    sdl3.SDL_Init(sdl3.SDL_INIT_AUDIO)
    def _quit_sdl():
        try:
            sdl3.SDL_Quit()
        except Exception:
            pass
    atexit.register(_quit_sdl)
except Exception:
    pass

from PySide6.QtWidgets import QApplication
from ui.main_window import MainWindow

def main() -> None:
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
------------------------------ END OF FILE ------------------------------

============================= combine.bat
# File: combine.bat (ext: .bat
# Dir : 
# Size: 2393 bytes
# Time: 21/11/2025 11:42
============================= combine.bat
@echo off
setlocal EnableExtensions EnableDelayedExpansion

REM ====== Configuration ======
set "OUTPUT_FILE=combined.py"

REM Use the current directory as the root (run this from your main folder)
set "ROOT=%CD%"
set "OUT_FULL=%ROOT%\%OUTPUT_FILE%"

REM Delete output file if it exists
del "%OUTPUT_FILE%" 2>nul

REM ================== Directory Details (Tree + Detailed DIR) ==================
>>"%OUTPUT_FILE%" echo ============================= DIRECTORY OVERVIEW =============================
>>"%OUTPUT_FILE%" echo Root: %ROOT%
>>"%OUTPUT_FILE%" echo Timestamp: %DATE% %TIME%
>>"%OUTPUT_FILE%" echo.
>>"%OUTPUT_FILE%" echo ----------------------------- TREE (with files) -----------------------------
tree "%ROOT%" /F >>"%OUTPUT_FILE%"
>>"%OUTPUT_FILE%" echo.
>>"%OUTPUT_FILE%" echo ------------------------- DETAILED DIRECTORY LISTING -------------------------
dir "%ROOT%" /S /A >>"%OUTPUT_FILE%"
>>"%OUTPUT_FILE%" echo.
>>"%OUTPUT_FILE%" echo ============================================================================
>>"%OUTPUT_FILE%" echo(

REM ================== Concatenate ALL files (any extension) ======================
for /f "delims=" %%f in ('
  dir /b /s /a:-d "%ROOT%\*" ^| sort
') do (
  REM Skip the output file itself
  if /i not "%%~f"=="%OUT_FULL%" (
    REM Build nice relative labels
    set "ABS=%%~f"
    set "REL=!ABS:%ROOT%\=!"          REM e.g. sub\pkg\file.ext
    set "DIRABS=%%~dpf"
    set "DIRREL=!DIRABS:%ROOT%\=!"     REM e.g. sub\pkg\
    set "SIZE=%%~zf"
    set "TIME=%%~tf"
    set "EXT=%%~xf"

    echo Adding !REL!...

    REM Safe header lines (use echo() so parentheses are harmless)
    >>"%OUTPUT_FILE%" echo(============================= !REL!
    >>"%OUTPUT_FILE%" echo(# File: %%~nxf (ext: !EXT!)
    >>"%OUTPUT_FILE%" echo(# Dir : !DIRREL!
    >>"%OUTPUT_FILE%" echo(# Size: !SIZE! bytes
    >>"%OUTPUT_FILE%" echo(# Time: !TIME!
    >>"%OUTPUT_FILE%" echo(============================= !REL!

    REM Append file contents (binary files will be dumped raw)
    type "%%~f">>"%OUTPUT_FILE%"

    REM Separator line after content
    >>"%OUTPUT_FILE%" echo(
    >>"%OUTPUT_FILE%" echo ------------------------------ END OF FILE ------------------------------
    >>"%OUTPUT_FILE%" echo(
  )
)

echo All files from "%ROOT%" and subfolders combined into "%OUTPUT_FILE%".
pause

------------------------------ END OF FILE ------------------------------

# Dir : 
# Size: 2393 bytes
# Time: 21/11/2025 11:42
============================= combine.bat
============================= DIRECTORY OVERVIEW =============================
Root: C:\Projects\sense-pi-local-recording-live\to_be_integrated
Timestamp: 24/11/2025 23:14:05.14

----------------------------- TREE (with files) -----------------------------
Folder PATH listing for volume Windows-SSD
Volume serial number is 60BC-E58B
C:\PROJECTS\SENSE-PI-LOCAL-RECORDING-LIVE\TO_BE_INTEGRATED
¦   app.py
¦   combine.bat
¦   combined.py
¦   requirements.txt
¦   __init__.py
¦   
+---core
¦       models.py
¦       state.py
¦       __init__.py
¦       
+---data
¦       base.py
¦       live_reader.py
¦       mqtt_source.py
¦       
+---Images
¦       sensors.jpg
¦       
+---plotting
¦       plotter.py
¦       __init__.py
¦       
+---sonify
¦   ¦   notes_method.py
¦   ¦   
¦   +---utils
¦           audio.py
¦           dsp.py
¦           __init__.py
¦           
+---tests
¦       smoke_signals.py
¦       test_sampling.py
¦       __init__.py
¦       
+---ui
¦   ¦   fft_view.py
¦   ¦   main_window.py
¦   ¦   styles.py
¦   ¦   tab_fft.py
¦   ¦   tab_recorder.py
¦   ¦   tab_signals.py
¦   ¦   widgets.py
¦   ¦   __init__.py
¦   ¦   
¦   +---recorder
¦           capture_tab.py
¦           fft_tab.py
¦           split_csv_tab.py
¦           view_csv_tab.py
¦           __init__.py
¦           
+---util
    ¦   calibration.py
    ¦   ringbuf.py
    ¦   __init__.py
    ¦   
    +---__pycache__
            calibration.cpython-311.pyc
            calibration.cpython-312.pyc
            ringbuf.cpython-311.pyc
            ringbuf.cpython-312.pyc
            __init__.cpython-311.pyc
            __init__.cpython-312.pyc
            

------------------------- DETAILED DIRECTORY LISTING -------------------------
 Volume in drive C is Windows-SSD
 Volume Serial Number is 60BC-E58B

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated

24/11/2025  23:14    <DIR>          .
24/11/2025  23:02    <DIR>          ..
21/09/2025  00:09               619 app.py
21/11/2025  11:42             2,393 combine.bat
24/11/2025  23:14             1,794 combined.py
24/11/2025  23:06    <DIR>          core
24/11/2025  23:07    <DIR>          data
24/11/2025  23:07    <DIR>          Images
24/11/2025  23:08    <DIR>          plotting
25/09/2025  08:39               413 requirements.txt
24/11/2025  23:08    <DIR>          sonify
24/11/2025  23:06    <DIR>          tests
24/11/2025  23:09    <DIR>          ui
24/11/2025  23:09    <DIR>          util
16/09/2025  08:39                60 __init__.py
               5 File(s)          5,279 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\core

24/11/2025  23:06    <DIR>          .
24/11/2025  23:14    <DIR>          ..
29/09/2025  11:58               968 models.py
16/09/2025  18:16             1,573 state.py
16/09/2025  08:39                65 __init__.py
               3 File(s)          2,606 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\data

24/11/2025  23:07    <DIR>          .
24/11/2025  23:14    <DIR>          ..
16/09/2025  08:39             2,366 base.py
16/09/2025  13:37               677 live_reader.py
16/11/2025  12:16            16,378 mqtt_source.py
               3 File(s)         19,421 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\Images

24/11/2025  23:07    <DIR>          .
24/11/2025  23:14    <DIR>          ..
24/11/2025  23:07                12 sensors.jpg
               1 File(s)             12 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\plotting

24/11/2025  23:08    <DIR>          .
24/11/2025  23:14    <DIR>          ..
16/09/2025  13:15             1,521 plotter.py
16/09/2025  08:39                48 __init__.py
               2 File(s)          1,569 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\sonify

24/11/2025  23:08    <DIR>          .
24/11/2025  23:14    <DIR>          ..
18/09/2025  07:31            14,150 notes_method.py
24/11/2025  23:08    <DIR>          utils
               1 File(s)         14,150 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\sonify\utils

24/11/2025  23:08    <DIR>          .
24/11/2025  23:08    <DIR>          ..
18/09/2025  13:39               639 audio.py
19/09/2025  02:09             2,045 dsp.py
18/09/2025  13:41                94 __init__.py
               3 File(s)          2,778 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\tests

24/11/2025  23:06    <DIR>          .
24/11/2025  23:14    <DIR>          ..
16/09/2025  08:39               740 smoke_signals.py
16/11/2025  12:16             1,207 test_sampling.py
16/09/2025  08:39                42 __init__.py
               3 File(s)          1,989 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\ui

24/11/2025  23:09    <DIR>          .
24/11/2025  23:14    <DIR>          ..
19/09/2025  03:24             5,534 fft_view.py
25/09/2025  08:49             2,838 main_window.py
24/11/2025  23:08    <DIR>          recorder
16/09/2025  08:39               775 styles.py
25/09/2025  09:53            10,945 tab_fft.py
29/09/2025  11:07             1,213 tab_recorder.py
16/11/2025  12:16            12,069 tab_signals.py
16/09/2025  13:10             2,709 widgets.py
29/09/2025  11:08                59 __init__.py
               8 File(s)         36,142 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\ui\recorder

24/11/2025  23:08    <DIR>          .
24/11/2025  23:09    <DIR>          ..
16/11/2025  12:16            20,240 capture_tab.py
29/09/2025  11:51            11,900 fft_tab.py
29/09/2025  11:49             8,171 split_csv_tab.py
29/09/2025  11:47             9,848 view_csv_tab.py
29/09/2025  10:50                40 __init__.py
               5 File(s)         50,199 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\util

24/11/2025  23:09    <DIR>          .
24/11/2025  23:14    <DIR>          ..
18/09/2025  10:43               856 calibration.py
16/09/2025  08:39             1,825 ringbuf.py
16/09/2025  08:39                47 __init__.py
24/11/2025  23:06    <DIR>          __pycache__
               3 File(s)          2,728 bytes

 Directory of C:\Projects\sense-pi-local-recording-live\to_be_integrated\util\__pycache__

24/11/2025  23:06    <DIR>          .
24/11/2025  23:09    <DIR>          ..
18/09/2025  10:56             1,533 calibration.cpython-311.pyc
20/09/2025  20:49             1,392 calibration.cpython-312.pyc
16/09/2025  11:17             3,431 ringbuf.cpython-311.pyc
20/09/2025  20:49             3,213 ringbuf.cpython-312.pyc
16/09/2025  11:17               244 __init__.cpython-311.pyc
20/09/2025  20:49               176 __init__.cpython-312.pyc
               6 File(s)          9,989 bytes

     Total Files Listed:
              43 File(s)        146,862 bytes
              35 Dir(s)  30,257,192,960 bytes free

============================================================================

============================= __init__.py
# File: __init__.py (ext: .py
# Dir : 
# Size: 60 bytes
# Time: 16/09/2025 08:39
============================= __init__.py
"""Root package for the Digital Twin Simple application."""

------------------------------ END OF FILE ------------------------------

============================= app.py
# File: app.py (ext: .py
# Dir : 
# Size: 619 bytes
# Time: 21/09/2025 00:09
============================= app.py
from __future__ import annotations
import os, sys, atexit

# Keep these if you like, they don't hurt:
os.environ.setdefault("SDL_AUDIODRIVER", "dummy")

try:
    import sdl3
    sdl3.SDL_Init(sdl3.SDL_INIT_AUDIO)
    def _quit_sdl():
        try:
            sdl3.SDL_Quit()
        except Exception:
            pass
    atexit.register(_quit_sdl)
except Exception:
    pass

from PySide6.QtWidgets import QApplication
from ui.main_window import MainWindow

def main() -> None:
    app = QApplication(sys.argv)
    window = MainWindow()
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
------------------------------ END OF FILE ------------------------------

============================= combine.bat
# File: combine.bat (ext: .bat
# Dir : 
# Size: 2393 bytes
# Time: 21/11/2025 11:42
============================= combine.bat
@echo off
setlocal EnableExtensions EnableDelayedExpansion

REM ====== Configuration ======
set "OUTPUT_FILE=combined.py"

REM Use the current directory as the root (run this from your main folder)
set "ROOT=%CD%"
set "OUT_FULL=%ROOT%\%OUTPUT_FILE%"

REM Delete output file if it exists
del "%OUTPUT_FILE%" 2>nul

REM ================== Directory Details (Tree + Detailed DIR) ==================
>>"%OUTPUT_FILE%" echo ============================= DIRECTORY OVERVIEW =============================
>>"%OUTPUT_FILE%" echo Root: %ROOT%
>>"%OUTPUT_FILE%" echo Timestamp: %DATE% %TIME%
>>"%OUTPUT_FILE%" echo.
>>"%OUTPUT_FILE%" echo ----------------------------- TREE (with files) -----------------------------
tree "%ROOT%" /F >>"%OUTPUT_FILE%"
>>"%OUTPUT_FILE%" echo.
>>"%OUTPUT_FILE%" echo ------------------------- DETAILED DIRECTORY LISTING -------------------------
dir "%ROOT%" /S /A >>"%OUTPUT_FILE%"
>>"%OUTPUT_FILE%" echo.
>>"%OUTPUT_FILE%" echo ============================================================================
>>"%OUTPUT_FILE%" echo(

REM ================== Concatenate ALL files (any extension) ======================
for /f "delims=" %%f in ('
  dir /b /s /a:-d "%ROOT%\*" ^| sort
') do (
  REM Skip the output file itself
  if /i not "%%~f"=="%OUT_FULL%" (
    REM Build nice relative labels
    set "ABS=%%~f"
    set "REL=!ABS:%ROOT%\=!"          REM e.g. sub\pkg\file.ext
    set "DIRABS=%%~dpf"
    set "DIRREL=!DIRABS:%ROOT%\=!"     REM e.g. sub\pkg\
    set "SIZE=%%~zf"
    set "TIME=%%~tf"
    set "EXT=%%~xf"

    echo Adding !REL!...

    REM Safe header lines (use echo() so parentheses are harmless)
    >>"%OUTPUT_FILE%" echo(============================= !REL!
    >>"%OUTPUT_FILE%" echo(# File: %%~nxf (ext: !EXT!)
    >>"%OUTPUT_FILE%" echo(# Dir : !DIRREL!
    >>"%OUTPUT_FILE%" echo(# Size: !SIZE! bytes
    >>"%OUTPUT_FILE%" echo(# Time: !TIME!
    >>"%OUTPUT_FILE%" echo(============================= !REL!

    REM Append file contents (binary files will be dumped raw)
    type "%%~f">>"%OUTPUT_FILE%"

    REM Separator line after content
    >>"%OUTPUT_FILE%" echo(
    >>"%OUTPUT_FILE%" echo ------------------------------ END OF FILE ------------------------------
    >>"%OUTPUT_FILE%" echo(
  )
)

echo All files from "%ROOT%" and subfolders combined into "%OUTPUT_FILE%".
pause

------------------------------ END OF FILE ------------------------------

# Dir : 
# Size: 2393 bytes
# Time: 21/11/2025 11:42
============================= combine.bat
============================= DIRECTORY OVERVIEW ===
------------------------------ END OF FILE ------------------------------

============================= core\__init__.py
# File: __init__.py (ext: .py
# Dir : core\
# Size: 65 bytes
# Time: 16/09/2025 08:39
============================= core\__init__.py
"""Data models and application state for Digital Twin Simple."""

------------------------------ END OF FILE ------------------------------

============================= core\models.py
# File: models.py (ext: .py
# Dir : core\
# Size: 968 bytes
# Time: 29/09/2025 11:58
============================= core\models.py
# core/models.py
from __future__ import annotations
from dataclasses import dataclass, field
from typing import List

@dataclass
class Calibration:
    """Per-channel multiplicative factor."""
    scale: float = 1.0

@dataclass
class MQTTSettings:
    """Connection parameters + recorder name & CA cert path."""
    host: str = "141.54.176.20"
    port: int = 8883
    username: str = "mqttuser"
    password: str = "!66442200"
    recorder: str = "Pi-2"
    ca_cert_path: str = "ca.crt" 
    initial_hz: int = 50          

@dataclass
class ChannelConfig:
    """Configuration for a single slot."""
    name: str = "Slot"
    enabled: bool = False
    sensor: str | None = None
    channel: str | None = None
    cal: Calibration = field(default_factory=Calibration)
    y_zoom: float = 1.0

@dataclass
class GlobalCalibration:
    """Global zero-mean offsets per slot."""
    enabled: bool = False
    offsets: List[float] = field(default_factory=lambda: [0.0] * 9)

------------------------------ END OF FILE ------------------------------

============================= core\state.py
# File: state.py (ext: .py
# Dir : core\
# Size: 1573 bytes
# Time: 16/09/2025 18:16
============================= core\state.py
# core/state.py
from __future__ import annotations
from dataclasses import dataclass, field
from typing import List

from .models import ChannelConfig, MQTTSettings, GlobalCalibration
from data.mqtt_source import MQTTSource

_DEFAULT_SLOT_NAMES = [
    "S0 ax (m/sÂ²)", "S0 ay (m/sÂ²)", "S0 gz (deg/s)",
    "S1 ax (m/sÂ²)", "S1 ay (m/sÂ²)", "S1 gz (deg/s)",
    "S2 ax (m/sÂ²)", "S2 ay (m/sÂ²)", "S2 gz (deg/s)",
]

@dataclass
class AppState:
    channels: List[ChannelConfig] = field(
        default_factory=lambda: [ChannelConfig(name=_DEFAULT_SLOT_NAMES[i], enabled=True) for i in range(9)]
    )
    data_source: str = "mqtt"

    mqtt: MQTTSettings = field(default_factory=MQTTSettings)
    global_cal: GlobalCalibration = field(default_factory=GlobalCalibration)

    # Shared live source (used by ALL tabs)
    source: MQTTSource | None = None

    def ensure_source(self) -> MQTTSource:
        if self.source is None:
            self.source = MQTTSource(self.mqtt)
        return self.source

    def start_source(self) -> None:
        src = self.ensure_source()
        src.start()  # idempotent
        # â¬‡ï¸ Ensure the device is commanded to the initial Hz right away
        try:
            if getattr(self.mqtt, "initial_hz", 0):
                src.switch_frequency(int(self.mqtt.initial_hz))
        except Exception:
            # non-fatal if broker is offline; the local estimate is already applied
            pass

    def stop_source(self) -> None:
        if self.source is not None:
            self.source.stop()  # safe if already stopped

------------------------------ END OF FILE ------------------------------

============================= data\base.py
# File: base.py (ext: .py
# Dir : data\
# Size: 2366 bytes
# Time: 16/09/2025 08:39
============================= data\base.py
"""Abstract interface for data sources.

All data sources used by the application should inherit from
:class:`DataSource` and implement its methods.  This base class does
not impose any threading model; implementations may use background
threads internally but should not expose them to the GUI layer.  The
:func:`read` method must always return a dictionary with a key for each
of the nine slots (``"slot_0"`` through ``"slot_8"``).  Arrays
associated with disabled slots should be empty.
"""

from __future__ import annotations

import numpy as np
from typing import Dict


class DataSource:
    """Protocol for data sources.

    Subclasses must implement ``start()``, ``stop()`` and ``read()``.  The
    base class does not provide any default behaviour.
    """

    def start(self) -> None:
        """Begin acquiring data.

        This method should establish any connections or initialise any
        resources required by the data source.  It should be idempotent: a
        subsequent call should have no effect if the source is already
        started.
        """
        raise NotImplementedError

    def stop(self) -> None:
        """Cease acquiring data and release resources.

        Implementations should ensure that all resources (e.g. sockets,
        file handles, background threads) are cleanly disposed.  It should
        be safe to call this method on an instance that is not currently
        started.
        """
        raise NotImplementedError

    def read(self, last_seconds: float) -> Dict[str, np.ndarray]:
        """Return the most recent data for each slot.

        The implementation should produce arrays of equal length for all
        slots that are enabled in the GUI.  The number of samples to
        return is determined by the ``last_seconds`` parameter, but
        implementations are free to choose an internal sampling frequency.
        Disabled slots should be represented by empty arrays.  The keys
        must be strings of the form ``slot_0``, ``slot_1``, â€¦ ``slot_8``.

        Parameters
        ----------
        last_seconds : float
            Time window length in seconds for which data should be
            returned.

        Returns
        -------
        Dict[str, numpy.ndarray]
            Mapping of slot identifiers to 1â€‘D numpy arrays.
        """
        raise NotImplementedError

------------------------------ END OF FILE ------------------------------

============================= data\live_reader.py
# File: live_reader.py (ext: .py
# Dir : data\
# Size: 677 bytes
# Time: 16/09/2025 13:37
============================= data\live_reader.py
# data/live_reader.py
from __future__ import annotations

import numpy as np
from .mqtt_source import MQTTSource

def get_slot_data(source: MQTTSource, seconds: float, slot_index: int) -> np.ndarray:
    """
    Read last `seconds` from the shared source, return 1-D numpy array
    for the requested slot. Never raises; returns empty array on any issue.
    """
    try:
        i = int(slot_index)
        d = source.read(float(seconds))
        y = d.get(f"slot_{i}", None)
        if y is None:
            return np.array([], dtype=float)
        return np.asarray(y, dtype=float).ravel()
    except Exception:
        return np.array([], dtype=float)

------------------------------ END OF FILE ------------------------------

============================= data\mqtt_source.py
# File: mqtt_source.py (ext: .py
# Dir : data\
# Size: 16378 bytes
# Time: 16/11/2025 12:16
============================= data\mqtt_source.py
from __future__ import annotations

import json
import threading
import time
from typing import Dict, Optional
import collections

import numpy as np
import paho.mqtt.client as mqtt

from core.models import MQTTSettings
from .base import DataSource
from util.ringbuf import RingBuffer
from util.rate_control import RateController, RateEstimate


# Map slot index to (sensor_index, data_type, component)
# Slots are: 0..2 -> S0 (ax, ay, gz), 3..5 -> S1 (ax, ay, gz), 6..8 -> S2 (ax, ay, gz)
_SLOT_MAP = {
    0: (0, "acc", "x"),
    1: (0, "acc", "y"),
    2: (0, "gyro", "z"),
    3: (1, "acc", "x"),
    4: (1, "acc", "y"),
    5: (1, "gyro", "z"),
    6: (2, "acc", "x"),
    7: (2, "acc", "y"),
    8: (2, "gyro", "z"),
}


def _topic_prefix(recorder: str) -> str:
    return f"BIM2in/{recorder}"


class MQTTSource(DataSource):
    """
    MQTT receiver compatible with the BIM2in topics.

    Behaviors:
    - Fixed-size ring buffers sized from ring_seconds * max_expected_hz.
    - Sampling interval is taken from /status messages:
        â€¢ "interval" (seconds) or
        â€¢ "frequency"/"hz" (Hz).
    - switch_frequency(hz) updates the local estimate immediately and
      publishes to the control topic; the chosen Hz is re-applied on reconnect.

    NEW:
    - Per-slot device timestamp ring buffers (epoch seconds). read() now
      returns both values and timestamps: keys "slot_i" and "slot_ts_i".
    """

    def __init__(
        self,
        settings: Optional[MQTTSettings] = None,
        ring_seconds: float = 20.0,
        max_expected_hz: float = 200.0,
    ) -> None:
        super().__init__()
        self.settings = settings or MQTTSettings()
        self.ring_seconds = float(ring_seconds)

        self.client: Optional[mqtt.Client] = None
        self.running = False

        # Per-slot ring buffers â€” size derived from window and a conservative max Hz
        buf_len = max(512, int(self.ring_seconds * float(max_expected_hz)))
        self._bufs: Dict[int, RingBuffer] = {i: RingBuffer(buf_len) for i in range(9)}
        # Per-slot timestamp buffers (device epoch seconds)
        self._ts_bufs: Dict[int, RingBuffer] = {i: RingBuffer(buf_len) for i in range(9)}

        # Track sample interval (seconds). Default to 20 Hz if no status yet.
        self._interval_s: float = 1.0 / 20.0

        self._rate = RateController(alpha=0.2, default_hz=20.0)

        # Remember the last requested sampling rate so we can re-apply it after reconnect.
        self._desired_hz: Optional[float] = None

        # Handshake for switch_frequency acknowledgements
        self._awaiting_hz: Optional[float] = None
        self._await_deadline: Optional[float] = None
        self._last_rate_apply_result: tuple[str | None, float | None, float | None] = (None, None, None)

        self._lock = threading.Lock()

        # --- lightweight telemetry for UI ---
        self._stats = {
            "status": 0,
            "data": 0,
            "acc": 0,
            "gyro": 0,
            "data_total": 0,
            "bytes_rx": 0,
        }
        self._last_status: dict | None = None
        self._recent_msgs = collections.deque(maxlen=200)  # (topic, payload_str, timestamp)
        self._last_msg_time: float | None = None

    # ---------- Public controls ----------

    def start(self) -> None:
        if self.running:
            return
        self._connect()
        self.running = True

    def stop(self) -> None:
        self.running = False
        if self.client is not None:
            try:
                self.client.loop_stop()
                self.client.disconnect()
            finally:
                self.client = None

    def read(self, last_seconds: float) -> Dict[str, np.ndarray]:
        """
        Return the last window of samples for each slot.

        n = window_seconds * estimated_hz, where estimated_hz is from the most
        recent status message (or falls back to 20 Hz).

        Returns keys:
          - slot_i: values for slot i (np.ndarray)
          - slot_ts_i: device timestamps (epoch seconds) for slot i (np.ndarray)
        """
        with self._lock:
            sr = (1.0 / self._interval_s) if self._interval_s > 0 else 20.0
        n = int(max(0, round(float(last_seconds) * sr)))

        out: Dict[str, np.ndarray] = {}
        for i in range(9):
            out[f"slot_{i}"] = self._bufs[i].get_last(n)
            out[f"slot_ts_{i}"] = self._ts_bufs[i].get_last(n)
        return out

    def switch_frequency(self, hz: int) -> None:
        """
        Update local estimate and publish control command (if connected).
        Keeps desired Hz to re-apply on reconnect.
        """
        self._desired_hz = float(hz)
        with self._lock:
            if hz > 0:
                self._interval_s = 1.0 / float(hz)
            self._awaiting_hz = float(hz)
            import time as _time
            self._await_deadline = _time.time() + 3.0
            self._last_rate_apply_result = (None, float(hz), _time.time())

        if self.client is not None:
            try:
                msg = json.dumps({"frequency": int(hz)})
                self.client.publish(self._topic_control(), msg, qos=1)
            except Exception:
                # Non-fatal: local estimate already applied
                pass

    def get_rate_apply_result(self) -> tuple[str | None, float | None, float | None]:
        with self._lock:
            return self._last_rate_apply_result

    def get_rate(self) -> RateEstimate:
        return self._rate.get()

    @property
    def estimated_hz(self) -> float:
        # Delegate to RateController (keeps legacy property working)
        try:
            return float(self._rate.get().hz_effective)
        except Exception:
            with self._lock:
                return (1.0 / self._interval_s) if self._interval_s > 0 else 20.0

    # ---------- Telemetry getters ----------

    def get_stats(self) -> dict:
        with self._lock:
            return dict(self._stats)

    def get_last_status(self) -> dict | None:
        # Return a deep copy to avoid accidental external mutation
        with self._lock:
            return None if self._last_status is None else json.loads(json.dumps(self._last_status))

    def get_recent_messages(self, limit: int | None = None) -> list[tuple[str, str, float]]:
        with self._lock:
            items = list(self._recent_msgs)[-int(limit):] if limit else list(self._recent_msgs)
            return [(t, p, ts) for (t, p, ts) in items]

    # ---------- Connection test (used by settings dialog) ----------

    @classmethod
    def quick_test(cls, settings_dict: dict, timeout_s: float = 4.0) -> tuple[bool, str]:
        """Try to connect, subscribe status+data, and see at least one message."""
        rec = settings_dict["recorder"]
        pref = _topic_prefix(rec)

        got_status = threading.Event()
        got_data = threading.Event()

        def on_connect(client, userdata, flags, rc, properties=None):
            client.subscribe([(f"{pref}/status", 0), (f"{pref}/data/#", 0)])

        def on_message(client, userdata, msg):
            try:
                if msg.topic.endswith("/status"):
                    got_status.set()
                elif "/data/" in msg.topic:
                    got_data.set()
            except Exception:
                pass

        c = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
        c.username_pw_set(settings_dict["username"], settings_dict["password"])
        c.tls_set(ca_certs=settings_dict["ca_cert_path"])
        c.on_connect = on_connect
        c.on_message = on_message

        try:
            c.connect(settings_dict["host"], int(settings_dict["port"]))
        except Exception as e:
            return False, f"Cannot connect: {e!s}"

        c.loop_start()
        t0 = time.time()
        try:
            while time.time() - t0 < timeout_s:
                if got_status.is_set() and got_data.is_set():
                    return True, "Connected and received status + data."
                time.sleep(0.05)
            if got_status.is_set():
                return False, "Connected and got status, but no data arrived."
            return False, "No status/data received."
        finally:
            c.loop_stop()
            try:
                c.disconnect()
            except Exception:
                pass

    # ---------- Internals ----------

    def _topic_status(self) -> str:
        return f"{_topic_prefix(self.settings.recorder)}/status"

    def _topic_data(self) -> str:
        return f"{_topic_prefix(self.settings.recorder)}/data/#"

    def _topic_control(self) -> str:
        return f"{_topic_prefix(self.settings.recorder)}/control"

    def _connect(self) -> None:
        c = mqtt.Client(mqtt.CallbackAPIVersion.VERSION2)
        c.username_pw_set(self.settings.username, self.settings.password)
        c.tls_set(ca_certs=self.settings.ca_cert_path)
        c.on_connect = self._on_connect
        c.on_disconnect = self._on_disconnect
        c.on_message = self._on_message
        c.user_data_set(self)
        c.connect(self.settings.host, int(self.settings.port))
        c.loop_start()
        self.client = c

    @staticmethod
    def _on_connect(client: mqtt.Client, userdata: "MQTTSource", flags, rc, properties=None):
        client.subscribe([(userdata._topic_status(), 0), (userdata._topic_data(), 0)])
        # Re-apply the last requested Hz on (re)connect.
        try:
            if userdata._desired_hz and userdata._desired_hz > 0:
                msg = json.dumps({"frequency": int(userdata._desired_hz)})
                client.publish(userdata._topic_control(), msg, qos=1)
        except Exception:
            pass

    @staticmethod
    def _on_disconnect(client: mqtt.Client, userdata: "MQTTSource", flags, rc, properties=None):
        # Keep local state; desired Hz is re-applied on next connect.
        pass

    @staticmethod
    def _on_message(client: mqtt.Client, userdata: "MQTTSource", msg):
        import json as _json, time as _time

        # decode (best-effort)
        try:
            payload = _json.loads(msg.payload.decode())
            payload_str = _json.dumps(payload, separators=(",", ":"))
        except Exception:
            payload = None
            payload_str = ""

        bytes_len = len(msg.payload) if msg.payload is not None else 0

        # ---- Status messages: update interval estimate + telemetry
        if msg.topic.endswith("/status"):
            try:
                interval = float((payload or {}).get("interval", 0.0) or 0.0)
            except Exception:
                interval = 0.0
            try:
                freq = float((payload or {}).get("frequency", (payload or {}).get("hz", 0.0)) or 0.0)
            except Exception:
                freq = 0.0

            with userdata._lock:
                if interval > 0.0:
                    userdata._interval_s = float(interval)
                elif freq > 0.0:
                    userdata._interval_s = 1.0 / float(freq)
                userdata._stats["status"] += 1
                userdata._stats["bytes_rx"] += bytes_len
                userdata._last_status = payload if isinstance(payload, dict) else None
                userdata._last_msg_time = _time.time()
                userdata._recent_msgs.append((msg.topic, payload_str or "<non-JSON>", userdata._last_msg_time))
                # Feed RateController (NEW)
                try:
                    userdata._rate.update_from_status(interval if interval > 0 else None,
                                                      freq if freq > 0 else None)
                except Exception:
                    pass

                # --- Handshake check for switch_frequency (Prompt E) ---
                try:
                    hz_reported = 0.0
                    if interval > 0:
                        hz_reported = 1.0 / float(interval)
                    elif freq > 0:
                        hz_reported = float(freq)
                    if userdata._awaiting_hz is not None:
                        ok = abs(hz_reported - userdata._awaiting_hz) / max(userdata._awaiting_hz, 1e-9) < 0.05
                        now = _time.time()
                        if ok:
                            userdata._last_rate_apply_result = ("ok", userdata._awaiting_hz, now)
                            userdata._awaiting_hz = None
                            userdata._await_deadline = None
                        elif userdata._await_deadline and now > userdata._await_deadline:
                            userdata._last_rate_apply_result = ("timeout", userdata._awaiting_hz, now)
                            userdata._awaiting_hz = None
                            userdata._await_deadline = None
                except Exception:
                    pass
            return

        # ---- Data messages: BIM2in/<rec>/data/Sensor-<n>/(acc|gyro)
        try:
            parts = msg.topic.split("/")
            sensor_str = parts[-2]  # "Sensor-0"
            dtype = parts[-1]       # "acc" or "gyro"
            sensor_idx = int(sensor_str.split("-")[1])
        except Exception:
            # still update generic telemetry
            with userdata._lock:
                userdata._stats["data"] += 1
                userdata._stats["data_total"] += 1
                userdata._stats["bytes_rx"] += bytes_len
                userdata._last_msg_time = _time.time()
                userdata._recent_msgs.append((msg.topic, payload_str or "<non-JSON>", userdata._last_msg_time))
            return

        # Extract device timestamp (epoch seconds) if present
        ts_dev: Optional[float]
        try:
            ts_dev = float((payload or {}).get("ts", 0.0) or 0.0)
        except Exception:
            ts_dev = None

        def push(slot_idx: int, val: float):
            with userdata._lock:
                userdata._bufs[slot_idx].push([val])
                if ts_dev is not None:
                    userdata._ts_bufs[slot_idx].push([ts_dev])

        # Telemetry counts + ring push
        if dtype == "acc":
            x = (payload or {}).get("x", None)
            y = (payload or {}).get("y", None)
            for slot, tpl in _SLOT_MAP.items():
                sidx, dtyp, comp = tpl
                if sidx == sensor_idx and dtyp == "acc":
                    if comp == "x" and x is not None:
                        push(slot, float(x))
                    if comp == "y" and y is not None:
                        push(slot, float(y))
            with userdata._lock:
                userdata._stats["acc"] += 1
                userdata._stats["data"] += 1
                userdata._stats["data_total"] += 1
                userdata._stats["bytes_rx"] += bytes_len
                userdata._last_msg_time = _time.time()
                userdata._recent_msgs.append((msg.topic, payload_str or "<non-JSON>", userdata._last_msg_time))

        elif dtype == "gyro":
            z = (payload or {}).get("z", None)
            for slot, tpl in _SLOT_MAP.items():
                sidx, dtyp, comp = tpl
                if sidx == sensor_idx and dtyp == "gyro" and comp == "z" and z is not None:
                    push(slot, float(z))
            with userdata._lock:
                userdata._stats["gyro"] += 1
                userdata._stats["data"] += 1
                userdata._stats["data_total"] += 1
                userdata._stats["bytes_rx"] += bytes_len
                userdata._last_msg_time = _time.time()
                userdata._recent_msgs.append((msg.topic, payload_str or "<non-JSON>", userdata._last_msg_time))
        # After updating buffers, feed RateController with a short ts window (NEW)
        try:
            ts_probe = userdata._ts_bufs[0].get_last(256)
            if ts_probe.size > 4:
                userdata._rate.update_from_timestamps(ts_probe)
        except Exception:
            pass

------------------------------ END OF FILE ------------------------------

============================= Images\sensors.jpg
# File: sensors.jpg (ext: .jpg
# Dir : Images\
# Size: 12 bytes
# Time: 24/11/2025 23:07
============================= Images\sensors.jpg
[image_file]
------------------------------ END OF FILE ------------------------------

============================= plotting\__init__.py
# File: __init__.py (ext: .py
# Dir : plotting\
# Size: 48 bytes
# Time: 16/09/2025 08:39
============================= plotting\__init__.py
"""Plotting helpers for Digital Twin Simple."""

------------------------------ END OF FILE ------------------------------

============================= plotting\plotter.py
# File: plotter.py (ext: .py
# Dir : plotting\
# Size: 1521 bytes
# Time: 16/09/2025 13:15
============================= plotting\plotter.py
"""Helper functions for creating and updating pyqtgraph plots.

By funnelling all pyqtgraph usage through a thin layer, the rest of the
application remains decoupled from the plotting library.
"""

from __future__ import annotations

import numpy as np
import pyqtgraph as pg


def create_plot(parent, x_label: str = "Data points", y_label: str = ""):
    """Create a new pyqtgraph plot inside the given parent widget.

    The plot has its grid enabled and mouse interaction disabled.
    Axis labels are set from the provided arguments.
    """
    plot_widget = pg.PlotWidget(parent=parent)
    plot_widget.showGrid(x=True, y=True, alpha=0.3)
    plot_widget.setLabel('left', y_label)
    plot_widget.setLabel('bottom', x_label)
    plot_widget.setMouseEnabled(x=False, y=False)
    # Create a new curve; do not fill until data is provided.
    curve = plot_widget.plot([], [])
    return plot_widget, curve


def update_curve(curve: pg.PlotDataItem, y: np.ndarray | None, y_zoom: float) -> None:
    """Update the given curve with new y-values.

    If the input array ``y`` is empty or None, the curve is cleared. The supplied
    ``y_zoom`` is applied multiplicatively to the data prior to plotting.
    """
    if y is None or len(y) == 0:
        curve.setData([], [])
        return
    data = np.asarray(y, dtype=float)
    if data.ndim != 1:
        data = data.ravel()
    zoom = max(1e-9, float(y_zoom))
    y_scaled = data * zoom
    x = np.arange(len(y_scaled), dtype=float)
    curve.setData(x, y_scaled)

------------------------------ END OF FILE ------------------------------

============================= requirements.txt
# File: requirements.txt (ext: .txt
# Dir : 
# Size: 413 bytes
# Time: 25/09/2025 08:39
============================= requirements.txt
# --- Qt GUI (QtCore/QtWidgets/QtMultimedia/WebEngine) ---
PySide6>=6.5
PySide6-Addons>=6.5

# --- Plotting ---
matplotlib>=3.5
pyqtgraph>=0.13
plotly

# --- Numerics ---
numpy>=1.22
scipy>=1.8

# --- MQTT client (CallbackAPIVersion.VERSION2) ---
paho-mqtt>=2.0,<3

# --- MIDI/SoundFont rendering via PrettyMIDI â†’ (py)FluidSynth ---
pretty_midi>=0.2.10
mido>=1.2
pyfluidsynth>=1.3

# --- Misc/Tools ---
opstool

------------------------------ END OF FILE ------------------------------

============================= sonify\notes_method.py
# File: notes_method.py (ext: .py
# Dir : sonify\
# Size: 14150 bytes
# Time: 18/09/2025 07:31
============================= sonify\notes_method.py
from __future__ import annotations

"""
Notes-based sonification helpers and FluidSynth renderer.

- Puts FluidSynth in 'no audio' mode (render-to-buffer only) before importing pretty_midi.
- Robust FFT + peak mapping to 200â€“1000 Hz.
- PrettyMIDI + FluidSynth render with selectable instrument and velocity.
- Optional snapping of mapped frequencies to a set of allowed pitch classes (scale).
"""

# â”€â”€ FluidSynth & SDL env BEFORE pretty_midi import â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
import os, sys
os.environ["FS_AUDIO_DRIVER"] = "null"          # no realtime audio device
os.environ.setdefault("FS_MIDI_DRIVER", "null")
os.environ.setdefault("FS_LOG_LEVEL", "error")
os.environ.setdefault("SDL_AUDIODRIVER", "dummy")

# Help Windows find FluidSynth DLLs (adjust if yours is elsewhere)
if sys.platform.startswith("win"):
    candidates = [
        os.environ.get("FLUIDSYNTH_BIN", ""),
        r"C:\Program Files\fluidsynth\bin",
        r"C:\Program Files (x86)\fluidsynth\bin",
    ]
    for d in candidates:
        if d and os.path.isdir(d):
            try:
                os.add_dll_directory(d)  # Python 3.8+
            except Exception:
                pass
            os.environ["PATH"] = d + os.pathsep + os.environ.get("PATH", "")
            break

# â”€â”€ imports â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
from dataclasses import dataclass
from typing import Iterable, List, Literal, Optional, Sequence

import numpy as np

# robust peak picking (SciPy optional)
try:
    from scipy.signal import find_peaks, detrend as _sp_detrend
    _HAS_SCIPY = True
except Exception:  # pragma: no cover
    _HAS_SCIPY = False
    _sp_detrend = None  # type: ignore

try:
    import pretty_midi  # type: ignore
    _HAS_PRETTY = True
    _IMPORT_ERR: Exception | None = None
except Exception as e:  # pragma: no cover
    pretty_midi = None  # type: ignore
    _HAS_PRETTY = False
    _IMPORT_ERR = e


# â”€â”€ FFT + peak picking â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
def one_sided_fft(
    signal: np.ndarray,
    fs: float,
    *,
    detrend: str = "mean",  # 'none' | 'mean' | 'linear'
) -> tuple[np.ndarray, np.ndarray]:
    """
    One-sided FFT using a Hann window; returns (freq_hz, amplitude_linear).

    detrend:
      - 'none'   : no bias removal
      - 'mean'   : subtract mean (default; kills DC spike)
      - 'linear' : subtract best-fit line (SciPy if available; else LSQ fallback)
    """
    x = np.asarray(signal, dtype=float).ravel()
    n = int(x.size)
    if n == 0 or fs <= 0:
        return np.empty(0), np.empty(0)

    if detrend == "mean":
        x = x - float(np.mean(x))
    elif detrend == "linear":
        if _HAS_SCIPY and _sp_detrend is not None:
            x = _sp_detrend(x, type="linear")  # type: ignore
        else:
            t = np.arange(n, dtype=float)
            t -= t.mean()
            denom = float(np.dot(t, t)) or 1.0
            a = float(np.dot(t, x - x.mean())) / denom
            b = float(x.mean())
            x = x - (a * t + b)
    # else 'none'

    window = np.hanning(n)
    amp = 2.0 / n * np.abs(np.fft.rfft(x * window))
    freq = np.fft.rfftfreq(n, d=1.0 / float(fs))
    return freq, amp


def _quad_interp(f: np.ndarray, A: np.ndarray, i: int) -> float:
    """
    Quadratic (parabolic) interpolation around bin i to refine the peak frequency.
    Returns refined frequency in Hz.
    """
    if i <= 0 or i >= A.size - 1:
        return float(f[i])
    a, b, c = float(A[i-1]), float(A[i]), float(A[i+1])
    denom = (a - 2*b + c)
    if denom == 0:
        return float(f[i])
    delta = 0.5 * (a - c) / denom  # shift in bins
    return float(f[i] + delta * (f[1] - f[0]))


def pick_peaks_advanced(
    signal: np.ndarray,
    fs: float,
    n: int,
    *,
    detrend: str = "mean",      # <--- NEW
    min_freq: float = 0.5,
    max_freq: float | None = None,
    min_separation_hz: float = 0.5,
    prominence_rel: float = 0.25,
) -> list[float]:
    """
    Robust top-N peaks with bandlimit, minimum spacing and relative prominence.
    """
    f, A = one_sided_fft(signal, fs, detrend=detrend)  # <--- pass through
    if A.size == 0:
        return []

    # band-limit
    lo = max(min_freq, 0.0)
    hi = max_freq if (max_freq is not None and max_freq > lo) else f[-1]
    m = (f >= lo) & (f <= hi)
    f_band, A_band = f[m], A[m]
    if A_band.size < 3:
        return []

    # absolute prominence threshold from robust stats
    a_med = np.median(A_band)
    a_max = float(A_band.max())
    prom_abs = max(0.0, float(a_med + prominence_rel * (a_max - a_med)))

    # minimum spacing in bins
    df = f_band[1] - f_band[0]
    min_dist_bins = max(1, int(round(min_separation_hz / max(df, 1e-12))))

    if _HAS_SCIPY:
        idx, props = find_peaks(A_band, distance=min_dist_bins, prominence=prom_abs)
        scores = props.get("prominences", A_band[idx])
    else:
        # simple fallback: local maxima + distance + amplitude threshold
        idx = np.where((A_band[1:-1] > A_band[:-2]) & (A_band[1:-1] >= A_band[2:]))[0] + 1
        idx = idx[A_band[idx] >= prom_abs]
        # greedy non-maximum suppression by amplitude
        idx = idx[np.argsort(A_band[idx])[::-1]]
        kept = []
        last_bin = -10**9
        for i in idx:
            if (i - last_bin) >= min_dist_bins:
                kept.append(i); last_bin = i
        idx = np.array(kept, dtype=int)
        scores = A_band[idx] if idx.size else np.array([], dtype=float)

    if idx.size == 0:
        return []

    # sort by score, take top N
    order = np.argsort(scores)[::-1][: int(max(1, n))]
    idx = idx[order]

    # refine frequency with quadratic interpolation
    out = []
    for i in idx:
        # map band index back to full-fft index
        full_i = np.nonzero(m)[0][i]
        out.append(_quad_interp(f, A, full_i))
    # sort ascending if you want fundamentals first visually
    return sorted(out)


def top_n_freqs(signal: np.ndarray, fs: float, n: int, *, detrend: str = "mean") -> List[float]:
    """Strongest n peaks by amplitude (DC bin always dropped)."""
    freq, amp = one_sided_fft(signal, fs, detrend=detrend)
    if freq.size <= 1:
        return []
    freq, amp = freq[1:], amp[1:]  # drop DC bin
    if amp.size == 0:
        return []
    idx = np.argsort(amp)[-int(max(1, n)) :][::-1]
    return freq[idx].tolist()


# â”€â”€ mapping to an audible band â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
MappingMethod = Literal[
    "Linear scale",
    "Octave shift",
    "Nearest note",
    "Constant offset",
]

def _nearest_note_hz(f: float) -> float:
    """Snap a frequency to the nearest MIDI pitch and convert back to Hz."""
    if not pretty_midi:
        return float(f)
    midi = int(round(pretty_midi.hz_to_note_number(float(f))))  # type: ignore
    return float(pretty_midi.note_number_to_hz(midi))  # type: ignore


def map_frequencies(
    freqs: List[float],
    method: MappingMethod,
    ref_note_hz: float = 261.63,  # C4
    scale: float | None = None,
) -> List[float]:
    """
    Map frequencies into 200â€“1000 Hz using the selected method.
    If method is 'Linear scale', the first frequency is scaled to ref_note_hz.
    """
    if not freqs:
        return []
    mapped: List[float] = []

    if method == "Linear scale":
        factor = (ref_note_hz / max(freqs[0], 1e-6)) if (scale is None) else float(scale)
        mapped = [float(f) * factor for f in freqs]
    elif method == "Octave shift":
        for f in freqs:
            f = float(f)
            while f < 20.0:
                f *= 2.0
            mapped.append(f)
    elif method == "Nearest note":
        factor = ref_note_hz / max(freqs[0], 1e-6)
        mapped = [_nearest_note_hz(float(f) * factor) for f in freqs]
    elif method == "Constant offset":
        offset = ref_note_hz - float(freqs[0])
        mapped = [float(f) + offset for f in freqs]
    else:
        mapped = [float(f) for f in freqs]

    # Clamp into 200..1000 Hz via octave shifts
    audible: List[float] = []
    for f in mapped:
        while f < 200.0:
            f *= 2.0
        while f > 1000.0:
            f /= 2.0
        audible.append(float(f))
    return audible


# â”€â”€ scale constraint (allowed pitch classes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
_PCS = {
    "C":0, "C#":1, "Db":1, "D":2, "D#":3, "Eb":3, "E":4, "Fb":4, "E#":5,
    "F":5, "F#":6, "Gb":6, "G":7, "G#":8, "Ab":8, "A":9, "A#":10, "Bb":10, "B":11, "Cb":11, "B#":0
}

def snap_hz_to_allowed_pitch_classes(f_hz: float, allowed_pcs: Sequence[int]) -> float:
    """Quantize frequency to the nearest MIDI note whose pitch class is in allowed_pcs."""
    if f_hz <= 0 or not allowed_pcs:
        return float(f_hz)
    m_real = 69.0 + 12.0 * np.log2(float(f_hz) / 440.0)
    k0 = int(np.floor(m_real))
    best_k, best_err = k0, float("inf")
    for delta in range(-24, 25):  # Â±2 octaves search is plenty
        k = k0 + delta
        if (k % 12) in allowed_pcs:
            err = abs(k - m_real)
            if err < best_err:
                best_k, best_err = k, err
                if err < 0.5:  # already nearest semitone
                    pass
    return float(440.0 * (2.0 ** ((best_k - 69.0) / 12.0)))

def constrain_to_pitch_classes(freqs_hz: Sequence[float], allowed_pcs: Sequence[int]) -> List[float]:
    """Apply snap_hz_to_allowed_pitch_classes to each frequency."""
    if not allowed_pcs:
        return [float(f) for f in freqs_hz]
    return [snap_hz_to_allowed_pitch_classes(float(f), allowed_pcs) for f in freqs_hz]


# â”€â”€ FluidSynth renderer (PrettyMIDI) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
PlayMode = Literal[
    "Method 1 â€“ Sweep",
    "Method 2A â€“ Sequence",
    "Method 2B â€“ Chord",
    "Method 3 â€“ Scale melody",
    "Method 4 â€“ AM-Chord",
]

@dataclass
class FluidConfig:
    sample_rate: int = 44100
    note_ms: int = 120
    transpose_st: int = 0
    mode: PlayMode = "Method 2A â€“ Sequence"
    soundfont_path: str = ""      # must exist
    instrument: int = 0           # GM program (0â€“127)
    velocity: int = 110           # 1â€“127


class FluidNoteEngine:
    """Render mono float32 PCM chunks from a list of pitches via PrettyMIDI â†’ FluidSynth."""

    def __init__(self, cfg: FluidConfig) -> None:
        if not _HAS_PRETTY:  # env-specific failure
            raise RuntimeError(
                f"pretty_midi import failed: {str(_IMPORT_ERR) if _IMPORT_ERR else 'unknown error'}"
            )
        if not cfg.soundfont_path or not os.path.isfile(cfg.soundfont_path):
            raise RuntimeError("SoundFont (.sf2) not found or not set.")
        self.cfg = cfg
        self._seq_idx = 0

    # live updaters
    def set_mode(self, mode: PlayMode) -> None:
        self.cfg.mode = mode

    def set_transpose(self, semitones: int) -> None:
        self.cfg.transpose_st = int(semitones)

    def set_note_ms(self, ms: int) -> None:
        self.cfg.note_ms = max(20, int(ms))

    def set_soundfont(self, path: str) -> None:
        if not path or not os.path.isfile(path):
            raise RuntimeError("SoundFont (.sf2) not found or not set.")
        self.cfg.soundfont_path = path

    def set_instrument(self, program: int) -> None:
        self.cfg.instrument = int(np.clip(program, 0, 127))

    def set_velocity(self, velocity: int) -> None:
        self.cfg.velocity = int(np.clip(velocity, 1, 127))

    def render_chunk(self, pitches_hz: Iterable[float]) -> np.ndarray:
        """Render a mono float32 buffer of length note_ms * sr / 1000 from pitches_hz."""
        pitches = list(pitches_hz) or [440.0]

        # transpose in Hz
        factor = 2 ** (self.cfg.transpose_st / 12.0)
        pitches = [float(p) * factor for p in pitches]

        dur = float(self.cfg.note_ms) / 1000.0
        sr = int(self.cfg.sample_rate)
        vel = int(self.cfg.velocity)

        pm = pretty_midi.PrettyMIDI()  # type: ignore
        inst = pretty_midi.Instrument(program=int(self.cfg.instrument))  # type: ignore

        mode = self.cfg.mode
        if mode == "Method 1 â€“ Sweep":
            steps = max(3, len(pitches))
            for f in np.linspace(pitches[0], pitches[-1], steps):
                inst.notes.append(
                    pretty_midi.Note(velocity=vel,
                                     pitch=int(pretty_midi.hz_to_note_number(float(f))),  # type: ignore
                                     start=0.0, end=max(0.02, dur / steps))
                )
        elif mode in ("Method 2B â€“ Chord", "Method 4 â€“ AM-Chord"):
            for f in pitches:
                inst.notes.append(
                    pretty_midi.Note(velocity=max(1, vel - 10),
                                     pitch=int(pretty_midi.hz_to_note_number(float(f))),  # type: ignore
                                     start=0.0, end=dur)
                )
        else:  # Sequence / Scale melody
            f = float(pitches[self._seq_idx % len(pitches)])
            self._seq_idx += 1
            inst.notes.append(
                pretty_midi.Note(velocity=vel,
                                 pitch=int(pretty_midi.hz_to_note_number(f)),  # type: ignore
                                 start=0.0, end=dur)
            )

        pm.instruments.append(inst)  # type: ignore
        buf = pm.fluidsynth(fs=sr, sf2_path=self.cfg.soundfont_path)  # type: ignore

        # mixdown to mono if needed
        if buf.ndim > 1:
            buf = buf.mean(axis=1)

        n = int(round(dur * sr))
        if buf.shape[0] < n:
            buf = np.pad(buf, (0, n - buf.shape[0]))
        return buf[:n].astype(np.float32)

------------------------------ END OF FILE ------------------------------

============================= sonify\utils\__init__.py
# File: __init__.py (ext: .py
# Dir : sonify\utils\
# Size: 94 bytes
# Time: 18/09/2025 13:41
============================= sonify\utils\__init__.py
# File: sonify/utils/__init__.py
"""Utilities for sonification (DSP, audio IO, helpers)."""

------------------------------ END OF FILE ------------------------------

============================= sonify\utils\audio.py
# File: audio.py (ext: .py
# Dir : sonify\utils\
# Size: 639 bytes
# Time: 18/09/2025 13:39
============================= sonify\utils\audio.py
# File: sonify/utils/audio.py
from __future__ import annotations

import numpy as np
import wave
from pathlib import Path


def write_wav(path: str | Path, sample_rate: int, audio: np.ndarray) -> None:
    """
    Write mono float audio in [-1,1] to 16-bit PCM WAV.
    """
    Path(path).parent.mkdir(parents=True, exist_ok=True)
    a = np.asarray(audio, dtype=float)
    a = np.clip(a, -1.0, 1.0)
    pcm = (a * 32767.0).astype(np.int16)
    with wave.open(str(path), "wb") as wf:
        wf.setnchannels(1)
        wf.setsampwidth(2)
        wf.setframerate(int(sample_rate))
        wf.writeframes(pcm.tobytes())

------------------------------ END OF FILE ------------------------------

============================= sonify\utils\dsp.py
# File: dsp.py (ext: .py
# Dir : sonify\utils\
# Size: 2045 bytes
# Time: 19/09/2025 02:09
============================= sonify\utils\dsp.py
# File: sonify/utils/dsp.py
from __future__ import annotations

import numpy as np

# (â€¦existing imports and code stayâ€¦)

def butter_filter(sig: np.ndarray, fs: float, low_hz: float | None = None, high_hz: float | None = None, order: int = 4) -> np.ndarray:
    # (unchanged)
    â€¦

def smooth_moving_average(sig: np.ndarray, fs: float, win_ms: float) -> np.ndarray:
    # (unchanged)
    â€¦


# ----------------------- NEW: level + mapping helpers -----------------------

def abs_area_level(sig: np.ndarray, fs: float) -> float:
    """
    Return mean absolute amplitude of `sig` (proxy for 'absolute sum of areas' per time).
    If you want physical 'area', itâ€™s sum(|x|)*dt; dividing by duration is equivalent
    and is better for normalization. Returns 0..+inf (typically small).
    """
    x = np.asarray(sig, dtype=float).ravel()
    if x.size == 0 or fs <= 0:
        return 0.0
    # mean(|x|) == (sum(|x|)*dt) / (N*dt) -- duration-normalized "area"
    return float(np.mean(np.abs(x)))


def map_level_to_gain(level: float, min_thr: float, max_cap: float) -> float:
    """
    0 when level <= min_thr, 1 when level >= max_cap, linear in between.
    Clamp and handle bad params gracefully.
    """
    lv = float(level)
    lo = float(min_thr)
    hi = float(max_cap)

    if not np.isfinite(lv):
        lv = 0.0
    if not np.isfinite(lo):
        lo = 0.0
    if not np.isfinite(hi):
        hi = lo + 1.0

    if hi <= lo:
        hi = lo + 1e-4  # nudge to avoid zero division

    t = (lv - lo) / (hi - lo)
    if t <= 0.0:
        return 0.0
    if t >= 1.0:
        return 1.0
    return float(t)


def map_level_to_gain_with_floor(level: float, min_thr: float, max_cap: float, floor_pct: float) -> float:
    """
    Like map_level_to_gain but never below `floor_pct` (0..1).
    """
    floor = float(np.clip(floor_pct, 0.0, 1.0))
    g = map_level_to_gain(float(level), float(min_thr), float(max_cap))
    return float(floor + (1.0 - floor) * g)

------------------------------ END OF FILE ------------------------------

============================= tests\__init__.py
# File: __init__.py (ext: .py
# Dir : tests\
# Size: 42 bytes
# Time: 16/09/2025 08:39
============================= tests\__init__.py
"""Test suite for Digital Twin Simple."""

------------------------------ END OF FILE ------------------------------

============================= tests\smoke_signals.py
# File: smoke_signals.py (ext: .py
# Dir : tests\
# Size: 740 bytes
# Time: 16/09/2025 08:39
============================= tests\smoke_signals.py
"""Simple smoke test for the MQTTSource stub (returns empty arrays)."""

from __future__ import annotations

import os
import sys

# Ensure the package is importable when running this script directly.
root_dir = os.path.abspath(os.path.join(os.path.dirname(__file__), os.pardir))
if root_dir not in sys.path:
    sys.path.insert(0, root_dir)

from data.mqtt_source import MQTTSource


def main() -> None:
    src = MQTTSource()
    src.start()
    res = src.read(1.0)
    assert isinstance(res, dict), "Expected a dict from read()"
    assert len(res) == 9, "Expected nine slots"
    for arr in res.values():
        assert len(arr) == 0, "Expected empty arrays from MQTTSource stub"
    print("OK")


if __name__ == "__main__":
    main()

------------------------------ END OF FILE ------------------------------

============================= tests\test_sampling.py
# File: test_sampling.py (ext: .py
# Dir : tests\
# Size: 1207 bytes
# Time: 16/11/2025 12:16
============================= tests\test_sampling.py
from __future__ import annotations
import numpy as np
from util.rate_control import RateController
from util.resample import resample_to_fixed_rate


def test_rate_controller_fuses_status_and_ts():
    rc = RateController(alpha=0.5, default_hz=20.0)
    # only status
    e = rc.update_from_status(interval=None, hz=50.0)
    assert e.hz_raw_status > 45 and e.quality in ("status_only", "fused")
    # timestamps ~48-52 Hz
    t = np.cumsum(np.random.uniform(1/52.0, 1/48.0, size=400))
    e = rc.update_from_timestamps(t)
    assert e.hz_ts_window > 45
    assert e.hz_effective > 35


def test_resample_downsample_100_to_25():
    fs_in = 100.0
    t = np.arange(0.0, 2.0, 1.0/fs_in)
    y = np.sin(2*np.pi*2.0*t)
    t_out, y_out, last = resample_to_fixed_rate(t, y, 25.0, None)
    assert abs(t_out.size - int(2.0*25.0) - 1) <= 1  # approx count
    assert np.isfinite(y_out).all()


def test_resample_handles_drift():
    # 50 Hz jittered
    dt = np.random.normal(loc=1/50.0, scale=0.0005, size=4000)
    t = np.cumsum(dt); y = np.cos(2*np.pi*3.0*t)
    t_out, y_out, _ = resample_to_fixed_rate(t, y, 25.0, None)
    assert t_out.size > 0 and y_out.size == t_out.size

------------------------------ END OF FILE ------------------------------

============================= ui\__init__.py
# File: __init__.py (ext: .py
# Dir : ui\
# Size: 59 bytes
# Time: 29/09/2025 11:08
============================= ui\__init__.py
"""Qt user interface components for Digital Twin Simple."""
------------------------------ END OF FILE ------------------------------

============================= ui\fft_view.py
# File: fft_view.py (ext: .py
# Dir : ui\
# Size: 5534 bytes
# Time: 19/09/2025 03:24
============================= ui\fft_view.py
# ui/fft_view.py
from __future__ import annotations

from typing import Tuple, List
import numpy as np

from PySide6.QtWidgets import QWidget, QVBoxLayout
from matplotlib.figure import Figure
from matplotlib.backends.backend_qtagg import FigureCanvasQTAgg as FigureCanvas
import matplotlib.cm as cm

# Reuse your helpers
from sonify.notes_method import one_sided_fft, top_n_freqs, map_frequencies

# Optional note-name labeling (works even if pretty_midi not installed)
try:
    import pretty_midi  # type: ignore
    _HAS_PM = True
except Exception:
    pretty_midi = None  # type: ignore
    _HAS_PM = False

_NOTE_NAMES = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"]


def _hz_to_note_name(f: float) -> str:
    if not _HAS_PM:
        return f"{float(f):.1f} Hz"
    midi = int(round(pretty_midi.hz_to_note_number(float(f))))  # type: ignore
    return _NOTE_NAMES[midi % 12] + str(midi // 12 - 1)


class FFTNotesView(QWidget):
    """
    Two-panel Matplotlib view:
      â€¢ left  = natural FFT with peak markers
      â€¢ right = mapped FFT (band is adjustable) + note labels

    Public API:
      - set_mapped_xlim(lo_hz, hi_hz): adjust the mapped axis limits & title
      - update_view(...): recompute FFT/peaks and redraw both panels
    """

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)

        self.fig = Figure(figsize=(7.8, 3.2), dpi=100)
        self.ax_nat = self.fig.add_subplot(1, 2, 1)
        self.ax_map = self.fig.add_subplot(1, 2, 2)

        self.canvas = FigureCanvas(self.fig)
        lay = QVBoxLayout(self)
        lay.setContentsMargins(0, 0, 0, 0)
        lay.addWidget(self.canvas)

        # Current mapped-band x-limits (can be changed from the Notes tab)
        self._map_xlim: Tuple[float, float] = (200.0, 1000.0)

        self._setup_axes()

    # ---------------- axes & limits ----------------
    def _setup_axes(self) -> None:
        self.ax_nat.clear()
        self.ax_map.clear()

        self.ax_nat.set_title("Natural FFT")
        self.ax_nat.set_xlabel("Freq [Hz]")
        self.ax_nat.set_ylabel("Amplitude")
        self.ax_nat.grid(True, alpha=0.3)

        lo, hi = self._map_xlim
        self.ax_map.set_title(f"Mapped FFT ({lo:.0f}â€“{hi:.0f} Hz)")
        self.ax_map.set_xlabel("Freq [Hz]")
        self.ax_map.set_ylabel("Amplitude")
        self.ax_map.grid(True, alpha=0.3)
        self.ax_map.set_xlim(lo, hi)
        self.ax_map.set_ylim(0.0, 1.0)

        self.canvas.draw_idle()

    def _apply_mapped_xlim(self) -> None:
        lo, hi = self._map_xlim
        if hi <= lo:
            # keep sane ordering
            lo, hi = hi, lo
            self._map_xlim = (lo, hi)
        self.ax_map.set_xlim(lo, hi)
        self.ax_map.set_title(f"Mapped FFT ({lo:.0f}â€“{hi:.0f} Hz)")
        self.canvas.draw_idle()

    def set_mapped_xlim(self, lo_hz: float, hi_hz: float) -> None:
        """
        Public: update the mapped FFT x-axis limits and retitle the panel.
        """
        try:
            lo = float(lo_hz)
            hi = float(hi_hz)
        except Exception:
            return
        # clamp to positive and avoid degenerate limits
        lo = max(1e-6, lo)
        hi = max(1e-6, hi)
        if lo == hi:
            hi = lo * 1.001
        self._map_xlim = (lo, hi)
        self._apply_mapped_xlim()

    # ---------------- main redraw ----------------
    def update_view(
        self,
        signal: np.ndarray,
        fs: float,
        n_peaks: int,
        mapping_method: str,
        *,
        detrend: str = "mean",
        xlim_nat: Tuple[float, float] = (0.0, 10.0),
    ) -> tuple[list[float], list[float], list[str]]:
        """
        Redraw both panels for the given signal & settings.

        Returns:
            (nat_peaks_hz, mapped_peaks_hz, labels)
        """
        self._setup_axes()

        sig = np.asarray(signal, dtype=float).ravel()
        if sig.size == 0 or float(fs) <= 0:
            self.canvas.draw_idle()
            return [], [], []

        # Natural FFT
        f, A = one_sided_fft(sig, float(fs), detrend=detrend)
        self.ax_nat.plot(f, A, lw=0.7, color="k")
        try:
            self.ax_nat.set_xlim(float(xlim_nat[0]), float(xlim_nat[1]))
        except Exception:
            pass

        # Peaks + mapping for preview markers
        n = int(max(1, n_peaks))
        nat = top_n_freqs(sig, float(fs), n, detrend=detrend)
        mapped = map_frequencies(nat, mapping_method)

        labels = [_hz_to_note_name(x) for x in mapped]
        colors = [cm.get_cmap("tab10")(i % 10) for i in range(len(nat))]

        # Markers on natural
        for f0, c in zip(nat, colors):
            self.ax_nat.axvline(float(f0), color=c, ls=":", lw=1.0)

        # Mapped panel markers + labels
        lo, hi = self._map_xlim
        self.ax_map.set_xlim(lo, hi)
        self.ax_map.set_ylim(0.0, 1.0)
        for f1, lab, c in zip(mapped, labels, colors):
            self.ax_map.axvline(float(f1), color=c, ls="--", lw=1.0)
            self.ax_map.text(
                float(f1), 0.92, lab,
                rotation=90, ha="right", va="top",
                transform=self.ax_map.get_xaxis_transform(),
                color=c, fontsize=9,
            )

        self.canvas.draw_idle()
        return list(map(float, nat)), list(map(float, mapped)), labels

------------------------------ END OF FILE ------------------------------

============================= ui\main_window.py
# File: main_window.py (ext: .py
# Dir : ui\
# Size: 2838 bytes
# Time: 25/09/2025 08:49
============================= ui\main_window.py
# ui/main_window.py
from __future__ import annotations

from PySide6.QtCore import Qt
from PySide6.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QTabWidget, QLabel

from core.state import AppState
from .tab_signals import SignalsTab
from .tab_recorder import RecorderTab  # <-- NEW
from .tab_sonify_additive import SonificationAdditiveTab
from .tab_sonify_notes import SonificationNotesTab
from .tab_modeling import ModelingTab
from .styles import apply_styles
from .tab_fft import FFTTab
from .tab_mqtt import MQTTControlTab
from .tab_sonify_testing import SonificationTestingTab  # <-- NEW
from .tab_sonify_pure_tones import SonificationPureTonesTab


class MainWindow(QMainWindow):
    """Top-level window with six tabs."""

    def __init__(self, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.setWindowTitle("Digital Twin Simple")
        self.resize(1000, 700)

        self.state = AppState()

        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)
        layout.setContentsMargins(0, 0, 0, 0)

        self.tabs = QTabWidget()
        layout.addWidget(self.tabs)

        # Signals (time-domain)
        self.signals_tab = SignalsTab(self.state)
        self.tabs.addTab(self.signals_tab, "Signals")

        # Recorder (CSV)
        self.recorder_tab = RecorderTab(self.state)
        self.tabs.addTab(self.recorder_tab, "Record")

        # MQTT 
        # self.mqtt_tab = MQTTControlTab(self.state)
        # self.tabs.addTab(self.mqtt_tab, "MQTT â€“ Control")

        # FFT (frequency-domain, all 9 channels)
        self.fft_tab = FFTTab(self.state)
        self.tabs.addTab(self.fft_tab, "FFT")

        # Sonification tabs
        self.sonify_add = SonificationAdditiveTab(self.state)
        self.tabs.addTab(self.sonify_add, "Sonify â€“ Additive")

        # self.sonify_notes = SonificationNotesTab(self.state)
        # self.tabs.addTab(self.sonify_notes, "Sonify â€“ Notes")

        # NEW: Testing tab
        # self.sonify_testing = SonificationTestingTab(self)
        # self.tabs.addTab(self.sonify_testing, "Sonify â€“ Testing")

        # self.sonify_pure = SonificationPureTonesTab(self)
        # self.tabs.addTab(self.sonify_pure, "Sonify â€“ Pure Tones (Live)")

        # Modeling
        self.modeling_tab = ModelingTab(self)
        self.tabs.addTab(self.modeling_tab, "Modeling")

        # Placeholders (unchanged)
        for title in ["Analysis results", "Digital twin"]:
            page = QWidget()
            vbox = QVBoxLayout(page)
            label = QLabel("...")
            label.setAlignment(Qt.AlignHCenter | Qt.AlignVCenter)
            vbox.addStretch(1)
            vbox.addWidget(label)
            vbox.addStretch(1)
            self.tabs.addTab(page, title)

        apply_styles(self)

------------------------------ END OF FILE ------------------------------

============================= ui\recorder\__init__.py
# File: __init__.py (ext: .py
# Dir : ui\recorder\
# Size: 40 bytes
# Time: 29/09/2025 10:50
============================= ui\recorder\__init__.py
# Package marker for recorder sub-tabs

------------------------------ END OF FILE ------------------------------

============================= ui\recorder\capture_tab.py
# File: capture_tab.py (ext: .py
# Dir : ui\recorder\
# Size: 20240 bytes
# Time: 16/11/2025 12:16
============================= ui\recorder\capture_tab.py
from __future__ import annotations

import csv
import os
import time
from enum import Enum
from typing import List, Dict

import numpy as np
from PySide6.QtCore import QTimer, Qt, QDateTime
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QLabel, QPushButton,
    QFileDialog, QMessageBox, QCheckBox, QDoubleSpinBox, QGroupBox, QRadioButton, QFormLayout
)

from core.state import AppState
from data.mqtt_source import MQTTSource
from util.calibration import apply_global_and_scale  # per-slot, like your working code

# --- Constants / helpers -----------------------------------------------------

GYRO_SLOTS = {2, 5, 8}  # i % 3 == 2
_SUFFIX = ("ax", "ay", "gz")


def _compact_label_for_slot(i: int) -> str:
    """
    Map slot index 0..8 -> s{sensor_idx}_{ax|ay|gz}
    sensor_idx = i // 3 in [0,1,2]
    col       = i % 3  -> 0=ax, 1=ay, 2=gz
    """
    sensor_idx = i // 3
    suffix = _SUFFIX[i % 3]
    return f"s{sensor_idx}_{suffix}"


def _all_compact_labels() -> List[str]:
    return [_compact_label_for_slot(i) for i in range(9)]


ALL_LABELS = _all_compact_labels()


class RecMode(Enum):
    DRAIN = 1      # every device sample
    FIXED = 2      # resampled to user Hz
    LEGACY = 3     # old timer-per-estimated-hz


# --- UI ----------------------------------------------------------------------

class CaptureTab(QWidget):
    """
    Recorder (auto-rate, 9 channels total):
      - Reads latest samples from MQTTSource under keys "slot_0" ... "slot_8".
      - Applies the same per-slot calibration you used before.
      - Saves CSV with headers: timestamp_iso, t_rel_s, s0_ax, s0_ay, s0_gz, s1_ax, ...
      - UI has 9 checkboxes (select any subset to record).
    """

    def __init__(self, state: AppState, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.state = state

        # runtime
        self._recording = False
        self._rows: List[List[float | str]] = []    # [ts_iso, t_rel_s, values...]
        self._t0_monotonic: float | None = None
        self._selected_labels: List[str] = []
        self._rec_mode: RecMode = RecMode.DRAIN
        self._fixed_hz: float = 50.0
        self._last_ts_by_slot: dict[int, float] = {i: -float("inf") for i in range(9)}
        self._last_out_t: float | None = None  # for fixed-rate grid continuity

        # timers
        self._tick: QTimer | None = None
        self._fs_watchdog = QTimer(self)
        self._fs_watchdog.setInterval(2000)
        self._fs_watchdog.timeout.connect(self._maybe_adjust_interval)

        # ui
        self._chk: List[QCheckBox] = []
        self._build_ui()

    # --- Build UI -----------------------------------------------------------

    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(6, 6, 6, 6)
        layout.setSpacing(8)

        # Top controls
        row = QHBoxLayout()
        row.setSpacing(8)

        row.addWidget(QLabel("Recorder (MQTT Â· auto-rate)"))

        self.btn_record = QPushButton("Record")
        self.btn_record.clicked.connect(self.on_record)
        row.addWidget(self.btn_record)

        self.btn_stop = QPushButton("Stop")
        self.btn_stop.setEnabled(False)
        self.btn_stop.clicked.connect(self.on_stop)
        row.addWidget(self.btn_stop)

        self.btn_save = QPushButton("Save CSVâ€¦")
        self.btn_save.clicked.connect(self.on_save_csv)
        row.addWidget(self.btn_save)

        self.btn_clear = QPushButton("Clear")
        self.btn_clear.clicked.connect(self.on_clear)
        row.addWidget(self.btn_clear)

        row.addStretch(1)
        layout.addLayout(row)

        # Channel selection (exactly 9)
        sel = QHBoxLayout()
        sel.setSpacing(8)
        sel.addWidget(QLabel("Channels:"))

        self._chk = []
        for i in range(9):
            cb = QCheckBox(_compact_label_for_slot(i))
            cb.setChecked(True)
            self._chk.append(cb)
            sel.addWidget(cb)

        self.btn_all = QPushButton("All")
        self.btn_all.clicked.connect(self._select_all)
        sel.addWidget(self.btn_all)

        self.btn_none = QPushButton("None")
        self.btn_none.clicked.connect(self._select_none)
        sel.addWidget(self.btn_none)

        sel.addStretch(1)
        layout.addLayout(sel)

        # --- Recording mode group (NEW) ---
        grp = QGroupBox("Recording mode")
        frm = QFormLayout(grp)

        self.rb_drain = QRadioButton("Every sample (drain)")
        self.rb_fixed = QRadioButton("Fixed rate")
        self.rb_legacy = QRadioButton("Timerâ€‘tick (legacy)")
        self.rb_drain.setChecked(True)

        self.spin_fixed = QDoubleSpinBox(); self.spin_fixed.setRange(1.0, 1000.0)
        self.spin_fixed.setDecimals(2); self.spin_fixed.setValue(self._fixed_hz); self.spin_fixed.setSuffix(" Hz")

        # keep simple: enable spin only when fixed-rate is selected
        def _toggle_fixed(_):
            self.spin_fixed.setEnabled(self.rb_fixed.isChecked())
        self.rb_fixed.toggled.connect(_toggle_fixed); _toggle_fixed(None)

        frm.addRow(self.rb_drain)
        frm.addRow(self.rb_fixed, self.spin_fixed)
        frm.addRow(self.rb_legacy)
        layout.addWidget(grp)

        # connect handlers
        self.rb_drain.toggled.connect(lambda v: self._set_mode(RecMode.DRAIN if v else self._rec_mode))
        self.rb_fixed.toggled.connect(lambda v: self._set_mode(RecMode.FIXED if v else self._rec_mode))
        self.rb_legacy.toggled.connect(lambda v: self._set_mode(RecMode.LEGACY if v else self._rec_mode))
        self.spin_fixed.valueChanged.connect(lambda v: setattr(self, "_fixed_hz", float(v)))

        # Status row
        srow = QHBoxLayout()
        srow.setSpacing(8)
        self.lbl_status = QLabel("Idle")
        self.lbl_status.setTextInteractionFlags(Qt.TextSelectableByMouse)
        srow.addWidget(self.lbl_status)
        srow.addStretch(1)
        layout.addLayout(srow)

        self.setLayout(layout)

    # --- Selection helpers --------------------------------------------------

    def _current_selection(self) -> List[str]:
        return [_compact_label_for_slot(i) for i, cb in enumerate(self._chk) if cb.isChecked()]

    def _set_selection_enabled(self, enabled: bool) -> None:
        for cb in self._chk:
            cb.setEnabled(enabled)
        self.btn_all.setEnabled(enabled)
        self.btn_none.setEnabled(enabled)

    def _select_all(self) -> None:
        for cb in self._chk:
            cb.setChecked(True)

    def _select_none(self) -> None:
        for cb in self._chk:
            cb.setChecked(False)

    # --- Recording modes ---------------------------------------------------

    def _set_mode(self, m: RecMode) -> None:
        self._rec_mode = m
        # reset per-mode state
        self._last_ts_by_slot = {i: -float("inf") for i in range(9)}
        self._last_out_t = None
        self._update_status()

    def _choose_tick_ms(self) -> int:
        if self._rec_mode is RecMode.LEGACY:
            # derive from device estimate (old behavior)
            try:
                fs = self.state.ensure_source().get_rate().hz_effective
                return max(1, int(round(1000.0 / max(1.0, float(fs)))))
            except Exception:
                return 50
        # For DRAIN or FIXED, UI tick can be modest (drain is not tied to UI tick)
        return 40  # 25 Hz UI tick

    def _maybe_adjust_interval(self) -> None:
        if not self._recording or self._tick is None or self._rec_mode is not RecMode.LEGACY:
            return
        try:
            new_ms = self._choose_tick_ms()
            if new_ms != self._tick.interval():
                self._tick.start(new_ms)
        except Exception:
            pass

    # --- Recording control --------------------------------------------------

    def on_record(self) -> None:
        if self._recording:
            return

        # snapshot selection order
        selected = self._current_selection()
        if not selected:
            QMessageBox.information(self, "No channels selected",
                                    "Please select at least one channel.")
            return
        self._selected_labels = list(selected)
        self._set_selection_enabled(False)

        # Ensure source is running
        try:
            self.state.start_source()
        except Exception as e:
            self._set_selection_enabled(True)
            QMessageBox.critical(self, "MQTT start failed", str(e))
            return

        # Reset buffers/time
        self._rows.clear()
        self._t0_monotonic = time.monotonic()
        self._last_ts_by_slot = {i: -float("inf") for i in range(9)}
        self._last_out_t = None

        # Start timers based on mode
        if self._tick is None:
            self._tick = QTimer(self)
            self._tick.timeout.connect(self._sample_once)
        self._tick.start(self._choose_tick_ms())
        # watchdog only needed for LEGACY timer drift
        if self._rec_mode is RecMode.LEGACY:
            self._fs_watchdog.start()
        else:
            self._fs_watchdog.stop()

        self._recording = True
        self.btn_record.setEnabled(False)
        self.btn_stop.setEnabled(True)
        self._update_status()

    def on_stop(self) -> None:
        self._recording = False
        if self._tick:
            self._tick.stop()
        self._fs_watchdog.stop()
        self.btn_record.setEnabled(True)
        self.btn_stop.setEnabled(False)
        self._set_selection_enabled(True)
        self._update_status()

    def on_clear(self) -> None:
        if self._recording:
            if QMessageBox.question(self, "Clear",
                                    "Recording is active. Stop and clear?") != QMessageBox.Yes:
                return
            self.on_stop()
        self._rows.clear()
        self._t0_monotonic = None
        self._update_status()

    # --- Status -------------------------------------------------------------

    def _update_status(self) -> None:
        n = len(self._rows)
        names_str = ", ".join(self._selected_labels) if self._selected_labels else "-"
        if self._recording and self._t0_monotonic is not None:
            dur = time.monotonic() - self._t0_monotonic
            base = f"â— REC  |  {n} samples  |  {dur:0.1f} s  |  {names_str}"
        else:
            base = f"Idle  |  {n} samples  |  {names_str}"

        try:
            dev_hz = float(self.state.ensure_source().get_rate().hz_effective)
        except Exception:
            dev_hz = 0.0

        tick_hz = 0.0
        if self._tick and self._tick.interval() > 0:
            tick_hz = 1000.0 / float(self._tick.interval())

        mode_txt = {
            RecMode.DRAIN: "Every sample",
            RecMode.FIXED: f"Fixed {self._fixed_hz:.1f} Hz",
            RecMode.LEGACY: f"Timerâ€‘tick ~{tick_hz:.1f} Hz",
        }[self._rec_mode]

        self.lbl_status.setText(f"{base}  |  device ~{dev_hz:.1f} Hz  |  mode: {mode_txt}")

    def _set_status(self, txt: str) -> None:
        self.lbl_status.setText(txt)

    # --- Sampling & data path ----------------------------------------------

    def _read_latest_values(self) -> Dict[str, float]:
        """
        Read latest values from MQTTSource.read(window_s), which returns a dict with keys
        'slot_0'...'slot_8' -> ndarray. Map each slot_i to the compact CSV label.
        Apply per-slot calibration (same signature as before).
        """
        out: Dict[str, float] = {lab: np.nan for lab in ALL_LABELS}

        src = self.state.ensure_source()
        if not isinstance(src, MQTTSource):
            return out

        try:
            chunk = src.read(0.5)  # { "slot_0": np.ndarray, ..., "slot_8": np.ndarray }
        except Exception:
            return out

        if not isinstance(chunk, dict):
            return out

        for i in range(9):
            key = f"slot_{i}"
            arr = np.asarray(chunk.get(key, []), dtype=float)
            if arr.size > 0:
                # same per-slot calibration you used previously
                try:
                    arr_cal = apply_global_and_scale(self.state, i, arr)
                    v = float(arr_cal[-1])
                except Exception:
                    v = float(arr[-1])
                out[ALL_LABELS[i]] = v
        return out

    def _sample_once(self) -> None:
        src = self.state.ensure_source()
        try:
            chunk = src.read(1.0)  # recent window incl. slot_ts_i arrays
            if not isinstance(chunk, dict):
                return

            slot_data: dict[int, tuple[np.ndarray, np.ndarray]] = {}
            for i in range(9):
                ts = np.asarray(chunk.get(f"slot_ts_{i}", np.array([])), dtype=float)
                vals = np.asarray(chunk.get(f"slot_{i}", np.array([])), dtype=float)
                if vals.size:
                    try:
                        vals = np.asarray(apply_global_and_scale(self.state, i, vals), dtype=float)
                    except Exception:
                        vals = vals.astype(float, copy=False)
                slot_data[i] = (ts, vals)

            if self._rec_mode is RecMode.DRAIN:
                self._emit_rows_drain(slot_data)
            elif self._rec_mode is RecMode.FIXED:
                self._emit_rows_fixed(slot_data, self._fixed_hz)
            else:  # LEGACY
                self._emit_rows_legacy_snapshot(chunk)
        except Exception as e:
            self._set_status(f"Error: {e}")

    def _sorted_valid(self, ts: np.ndarray, y: np.ndarray) -> tuple[np.ndarray, np.ndarray]:
        ts = np.asarray(ts, dtype=float); y = np.asarray(y, dtype=float)
        m = np.isfinite(ts) & np.isfinite(y)
        ts = ts[m]; y = y[m]
        if ts.size:
            idx = np.argsort(ts, kind="mergesort")
            ts = ts[idx]; y = y[idx]
        return ts, y

    def _value_at_or_before(self, ts: np.ndarray, y: np.ndarray, t: float) -> float:
        # step-hold (ZOH) at time t
        if ts.size == 0:
            return float("nan")
        i = np.searchsorted(ts, t, side="right") - 1
        if i < 0:
            return float("nan")
        return float(y[i])

    def _interp_at(self, ts: np.ndarray, y: np.ndarray, t: np.ndarray) -> np.ndarray:
        # linear interpolation without extrapolation
        if ts.size < 2:
            return np.full_like(t, np.nan, dtype=float)
        tmin, tmax = float(ts[0]), float(ts[-1])
        t_clip = np.clip(t, tmin, tmax)
        # mask non-finite y
        m = np.isfinite(y)
        if np.count_nonzero(m) < 2:
            return np.full_like(t, np.nan, dtype=float)
        return np.interp(t_clip, ts[m], y[m])

    def _emit_rows_drain(self, slot_data: dict[int, tuple[np.ndarray, np.ndarray]]) -> None:
        # pace rows by reference channel (slot 0)
        ref = 0
        ts_ref, y_ref = slot_data.get(ref, (np.array([]), np.array([])))
        ts_ref, y_ref = self._sorted_valid(ts_ref, y_ref)
        if ts_ref.size == 0:
            return

        new_mask = ts_ref > self._last_ts_by_slot.get(ref, -float("inf"))
        if not np.any(new_mask):
            return

        ts_new = ts_ref[new_mask]
        self._last_ts_by_slot[ref] = float(ts_ref[-1])

        # Append one row per new ref timestamp; other channels: hold-last value at or before t
        for t_dev in ts_new:
            now_iso = QDateTime.currentDateTime().toString(Qt.ISODateWithMs)
            if self._t0_monotonic is None:
                self._t0_monotonic = time.monotonic()
            # keep t_rel from monotonic but strictly increasing: add a tiny epsilon
            t_rel = time.monotonic() - self._t0_monotonic + 1e-6

            row = [now_iso, f"{t_rel:.6f}"]
            for lab in self._selected_labels:
                i = ALL_LABELS.index(lab)
                ts_i, y_i = slot_data.get(i, (np.array([]), np.array([])))
                ts_i, y_i = self._sorted_valid(ts_i, y_i)
                v = self._value_at_or_before(ts_i, y_i, float(t_dev))
                row.append(v)
                if ts_i.size:
                    self._last_ts_by_slot[i] = max(self._last_ts_by_slot[i], float(ts_i[-1]))
            self._rows.append(row)

        self._update_status()

    def _emit_rows_fixed(self, slot_data: dict[int, tuple[np.ndarray, np.ndarray]], target_hz: float) -> None:
        # grid is derived from reference channel (slot 0); others interp linearly
        ref = 0
        ts_ref, y_ref = slot_data.get(ref, (np.array([]), np.array([])))
        ts_ref, y_ref = self._sorted_valid(ts_ref, y_ref)
        if ts_ref.size < 2 or target_hz <= 0:
            return

        from util.resample import resample_to_fixed_rate
        t_out, _y_out_ref, new_last = resample_to_fixed_rate(ts_ref, y_ref, float(target_hz), self._last_out_t)
        if t_out.size == 0:
            return
        self._last_out_t = float(new_last)

        for t_dev in t_out:
            now_iso = QDateTime.currentDateTime().toString(Qt.ISODateWithMs)
            if self._t0_monotonic is None:
                self._t0_monotonic = time.monotonic()
            t_rel = time.monotonic() - self._t0_monotonic + 1e-6

            row = [now_iso, f"{t_rel:.6f}"]
            for lab in self._selected_labels:
                i = ALL_LABELS.index(lab)
                ts_i, y_i = slot_data.get(i, (np.array([]), np.array([])))
                ts_i, y_i = self._sorted_valid(ts_i, y_i)
                v = float(self._interp_at(ts_i, y_i, np.array([t_dev]))[0])
                row.append(v)
                if ts_i.size:
                    self._last_ts_by_slot[i] = max(self._last_ts_by_slot[i], float(ts_i[-1]))
            self._rows.append(row)

        self._update_status()

    def _emit_rows_legacy_snapshot(self, chunk: dict) -> None:
        # this matches your old behavior: snapshot latest values once per tick
        now_iso = QDateTime.currentDateTime().toString(Qt.ISODateWithMs)
        if self._t0_monotonic is None:
            self._t0_monotonic = time.monotonic()
        t_rel = time.monotonic() - self._t0_monotonic
        values = self._read_latest_values()  # reuse your existing helper
        row = [now_iso, f"{t_rel:.6f}"] + [values.get(lab, np.nan) for lab in self._selected_labels]
        self._rows.append(row)
        self._update_status()

    # --- Saving -------------------------------------------------------------

    def on_save_csv(self) -> None:
        if not self._rows:
            QMessageBox.information(self, "Save CSV", "No samples to save yet.")
            return
        if self._recording:
            if QMessageBox.question(self, "Save while recording?",
                                    "Save current buffer to CSV while still recording?") != QMessageBox.Yes:
                return

        default_name = QDateTime.currentDateTime().toString("yyyyMMdd_HHmmss")
        default_path = os.path.join(os.getcwd(), f"recording_{default_name}.csv")

        path, _ = QFileDialog.getSaveFileName(
            self,
            "Save recording as CSV",
            default_path,
            "CSV files (*.csv)"
        )
        if not path:
            return

        try:
            headers = ["timestamp_iso", "t_rel_s"] + self._selected_labels
            with open(path, "w", newline="", encoding="utf-8") as f:
                w = csv.writer(f)
                w.writerow(headers)
                w.writerows(self._rows)
        except Exception as e:
            QMessageBox.critical(self, "Save failed", str(e))
            return

        QMessageBox.information(self, "Saved", f"Saved {len(self._rows)} samples to:\n{path}")

------------------------------ END OF FILE ------------------------------

============================= ui\recorder\fft_tab.py
# File: fft_tab.py (ext: .py
# Dir : ui\recorder\
# Size: 11900 bytes
# Time: 29/09/2025 11:51
============================= ui\recorder\fft_tab.py
from __future__ import annotations

import csv
from typing import List, Dict, Tuple, Optional

import numpy as np
import pyqtgraph as pg

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QFileDialog, QComboBox, QMessageBox, QDoubleSpinBox, QCheckBox
)

from core.state import AppState

# Prefer your robust FFT from repo; fallback if not present.
try:
    from sonify.notes_method import one_sided_fft  # type: ignore
except Exception:
    one_sided_fft = None


def _fallback_one_sided_fft(y: np.ndarray, fs: float, detrend: str = "mean") -> Tuple[np.ndarray, np.ndarray]:
    y = np.asarray(y, dtype=float).ravel()
    n = y.size
    if n < 2 or fs <= 0:
        return np.array([]), np.array([])
    if detrend == "mean":
        y = y - np.mean(y)
    elif detrend == "linear":
        t = np.arange(n, dtype=float)
        A = np.vstack([t, np.ones_like(t)]).T
        coef, *_ = np.linalg.lstsq(A, y, rcond=None)
        y = y - (coef[0] * t + coef[1])
    w = np.hanning(n)
    Y = np.fft.rfft(w * y)
    f = np.fft.rfftfreq(n, d=1.0 / fs)
    mag = np.abs(Y) / n
    return f, mag


class FFTTab(QWidget):
    """
    Offline FFT viewer for a recorded CSV:
      â€¢ Open CSV (expects: timestamp_iso, t_rel_s, channels...)
      â€¢ Choose channel
      â€¢ Select time window (drag region or numeric start/end)
      â€¢ Optional custom fs override (else estimated from t_rel_s)
      â€¢ Show time signal (top) and amplitude spectrum (bottom)
      â€¢ Detrend (Mean/Linear/None), Max frequency

    Uses one_sided_fft from your repo if available.
    """

    def __init__(self, state: AppState, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.state = state

        self._t: Optional[np.ndarray] = None
        self._cols: Dict[str, np.ndarray] = {}
        self._labels: List[str] = []
        self._fs_auto: float = 0.0

        self._build_ui()

    # ------------- UI -------------
    def _build_ui(self) -> None:
        root = QVBoxLayout(self)
        root.setContentsMargins(6, 6, 6, 6)
        root.setSpacing(8)

        top = QHBoxLayout()
        self.btn_open = QPushButton("Open CSVâ€¦")
        self.btn_open.clicked.connect(self.on_open)
        top.addWidget(self.btn_open)

        top.addWidget(QLabel("Channel:"))
        self.cmb_ch = QComboBox()
        self.cmb_ch.currentIndexChanged.connect(self._replot_all)
        top.addWidget(self.cmb_ch)

        top.addWidget(QLabel("Detrend:"))
        self.cmb_detrend = QComboBox()
        self.cmb_detrend.addItems(["Mean (DC remove)", "Linear", "None"])
        self.cmb_detrend.currentIndexChanged.connect(self._replot_all)
        top.addWidget(self.cmb_detrend)

        top.addWidget(QLabel("Max f (Hz):"))
        self.spin_fmax = QDoubleSpinBox()
        self.spin_fmax.setRange(0.0, 1e7)
        self.spin_fmax.setValue(0.0)  # 0 => full band
        self.spin_fmax.setDecimals(2)
        self.spin_fmax.valueChanged.connect(self._replot_fft_only)
        top.addWidget(self.spin_fmax)

        self.chk_custom_fs = QCheckBox("Use custom fs")
        self.chk_custom_fs.stateChanged.connect(self._replot_fft_only)
        top.addWidget(self.chk_custom_fs)

        self.spin_fs = QDoubleSpinBox()
        self.spin_fs.setRange(0.1, 1e7)
        self.spin_fs.setDecimals(6)
        self.spin_fs.setValue(100.0)
        self.spin_fs.setSuffix(" Hz")
        self.spin_fs.setEnabled(False)
        self.spin_fs.valueChanged.connect(self._replot_fft_only)
        top.addWidget(self.spin_fs)

        def _toggle_fs(_):
            self.spin_fs.setEnabled(self.chk_custom_fs.isChecked())
        self.chk_custom_fs.stateChanged.connect(_toggle_fs)

        top.addStretch(1)
        self.lbl_info = QLabel("No file loaded")
        self.lbl_info.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        top.addWidget(self.lbl_info)

        root.addLayout(top)

        # Time-domain plot (top)
        self.time_plot = pg.PlotWidget()
        self.time_plot.setLabel("bottom", "t", units="s")
        self.time_plot.setLabel("left", "x(t)")
        self.time_plot.showGrid(x=True, y=True, alpha=0.25)
        root.addWidget(self.time_plot, 1)

        # Draggable selection region over time plot
        self.region = pg.LinearRegionItem(values=[0.0, 1.0], brush=(100, 100, 255, 40))
        self.region.setZValue(10)
        self.region.sigRegionChanged.connect(self._sync_region_to_spins_then_fft)
        self.time_plot.addItem(self.region)

        # Numeric window controls
        win = QHBoxLayout()
        win.addWidget(QLabel("Window start (s):"))
        self.spin_t0 = QDoubleSpinBox(); self.spin_t0.setRange(-1e12, 1e12); self.spin_t0.setDecimals(6)
        self.spin_t0.valueChanged.connect(self._sync_spins_to_region_then_fft)
        win.addWidget(self.spin_t0)
        win.addWidget(QLabel("end (s):"))
        self.spin_t1 = QDoubleSpinBox(); self.spin_t1.setRange(-1e12, 1e12); self.spin_t1.setDecimals(6)
        self.spin_t1.valueChanged.connect(self._sync_spins_to_region_then_fft)
        win.addStretch(1)
        root.addLayout(win)

        # Frequency-domain plot (bottom)
        self.fft_plot = pg.PlotWidget()
        self.fft_plot.setLabel("bottom", "f", units="Hz")
        self.fft_plot.setLabel("left", "|X(f)|")
        self.fft_plot.showGrid(x=True, y=True, alpha=0.25)
        root.addWidget(self.fft_plot, 1)

        self.setLayout(root)

    # ------------- File I/O -------------
    def on_open(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, "Open CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "r", newline="", encoding="utf-8") as f:
                rdr = csv.reader(f)
                header = next(rdr)
                if len(header) < 3 or header[0] != "timestamp_iso" or header[1] != "t_rel_s":
                    raise ValueError("Unexpected CSV header. Expect 'timestamp_iso,t_rel_s,...'")
                labels = header[2:]
                t_arr: List[float] = []
                cols: Dict[str, List[float]] = {lab: [] for lab in labels}
                for row in rdr:
                    if not row:
                        continue
                    try:
                        t_arr.append(float(row[1]))
                        for i, lab in enumerate(labels, start=2):
                            v = row[i]
                            cols[lab].append(float(v) if v != '' else np.nan)
                    except Exception:
                        continue

            t = np.asarray(t_arr, dtype=float)
            self._t = t
            self._cols = {k: np.asarray(v, dtype=float) for k, v in cols.items()}
            self._labels = labels

            # sampling rate estimate from t_rel_s
            if t.size > 1 and (t[-1] - t[0]) > 0:
                self._fs_auto = (t.size - 1) / float(t[-1] - t[0])
            else:
                self._fs_auto = 0.0

            # Populate channel list
            self.cmb_ch.blockSignals(True)
            self.cmb_ch.clear()
            self.cmb_ch.addItems(self._labels)
            self.cmb_ch.blockSignals(False)

            # Set region to first few seconds
            if t.size:
                t0 = float(np.nanmin(t)); t1 = float(np.nanmax(t))
                span = t1 - t0
                if span <= 0:
                    a, b = t0, t0 + 1.0
                else:
                    width = min(5.0, span)
                    a, b = t0, t0 + width
                self.region.blockSignals(True); self.region.setRegion((a, b)); self.region.blockSignals(False)
                self.spin_t0.blockSignals(True); self.spin_t1.blockSignals(True)
                self.spin_t0.setValue(a); self.spin_t1.setValue(b)
                self.spin_t0.blockSignals(False); self.spin_t1.blockSignals(False)

            self.lbl_info.setText(f"N={t.size} Â· fs_autoâ‰ˆ{self._fs_auto:.6f} Hz")
            self._replot_all()
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))

    # ------------- Helpers -------------
    def _detrend_mode(self) -> str:
        txt = self.cmb_detrend.currentText().lower()
        if "linear" in txt:
            return "linear"
        if "none" in txt:
            return "none"
        return "mean"

    def _effective_fs(self) -> float:
        if self.chk_custom_fs.isChecked():
            return float(self.spin_fs.value())
        return float(self._fs_auto) if self._fs_auto > 0 else max(1e-6, float(self.spin_fs.value()))

    def _current_channel_series(self) -> Tuple[np.ndarray, np.ndarray]:
        if self._t is None or not self._labels:
            return np.array([]), np.array([])
        ch = self.cmb_ch.currentText() if self.cmb_ch.count() else None
        if not ch:
            return np.array([]), np.array([])
        y = self._cols.get(ch)
        if y is None:
            return np.array([]), np.array([])
        mask = np.isfinite(self._t) & np.isfinite(y)
        return self._t[mask], y[mask]

    def _window_mask(self, t: np.ndarray) -> np.ndarray:
        t0 = float(self.spin_t0.value())
        t1 = float(self.spin_t1.value())
        if t1 < t0:
            t0, t1 = t1, t0
        return (t >= t0) & (t <= t1)

    # ------------- Syncs -------------
    def _sync_region_to_spins_then_fft(self) -> None:
        a, b = self.region.getRegion()
        self.spin_t0.blockSignals(True); self.spin_t1.blockSignals(True)
        self.spin_t0.setValue(float(a)); self.spin_t1.setValue(float(b))
        self.spin_t0.blockSignals(False); self.spin_t1.blockSignals(False)
        self._replot_fft_only()

    def _sync_spins_to_region_then_fft(self) -> None:
        a = float(self.spin_t0.value()); b = float(self.spin_t1.value())
        self.region.blockSignals(True); self.region.setRegion((min(a, b), max(a, b))); self.region.blockSignals(False)
        self._replot_fft_only()

    # ------------- Plotting -------------
    def _replot_all(self) -> None:
        # time plot
        self.time_plot.clear()
        t, y = self._current_channel_series()
        if t.size and y.size:
            self.time_plot.plot(t, y)
            # keep and re-add region
            self.time_plot.addItem(self.region)
        # fft
        self._replot_fft_only()

    def _replot_fft_only(self) -> None:
        self.fft_plot.clear()
        t, y = self._current_channel_series()
        if t.size < 2 or y.size < 2:
            return

        m = self._window_mask(t)
        if not np.any(m):
            self.fft_plot.setTitle("No samples in selected window")
            return
        t_win = t[m]
        y_win = y[m]
        if y_win.size < 2:
            self.fft_plot.setTitle("Window too small")
            return

        fs = max(self._effective_fs(), 1e-9)
        detrend = self._detrend_mode()

        # prefer robust FFT if available
        if one_sided_fft is not None:
            try:
                f, mag = one_sided_fft(y_win, fs, detrend=detrend)  # type: ignore[arg-type]
            except Exception:
                f, mag = _fallback_one_sided_fft(y_win, fs, detrend=detrend)
        else:
            f, mag = _fallback_one_sided_fft(y_win, fs, detrend=detrend)

        fmax = float(self.spin_fmax.value())
        if fmax > 0.0:
            sel = f <= fmax
            f, mag = f[sel], mag[sel]

        self.fft_plot.plot(f, mag)
        self.fft_plot.setTitle(f"fs = {fs:.6f} Hz Â· detrend = {detrend} Â· window = [{t_win[0]:.3f}, {t_win[-1]:.3f}] s")

------------------------------ END OF FILE ------------------------------

============================= ui\recorder\split_csv_tab.py
# File: split_csv_tab.py (ext: .py
# Dir : ui\recorder\
# Size: 8171 bytes
# Time: 29/09/2025 11:49
============================= ui\recorder\split_csv_tab.py
from __future__ import annotations

import csv
import os
import re
from typing import List, Dict, Optional

import numpy as np
import pyqtgraph as pg

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel, QFileDialog,
    QTableWidget, QTableWidgetItem, QMessageBox, QAbstractItemView, QComboBox
)

from core.state import AppState


def _safe_name(name: str) -> str:
    name = name.strip()
    name = re.sub(r"[^A-Za-z0-9._-]+", "_", name)
    return name or "slice"


class SplitCSVTab(QWidget):
    """
    Split a recorded CSV into multiple CSVs by [start,end] seconds (t_rel_s).

    Additions:
      â€¢ Preview: choose which column to visualize to help pick ranges.
      â€¢ Splitting always keeps ALL columns; preview choice does not affect output.
    """

    def __init__(self, state: AppState, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.state = state

        self._path: Optional[str] = None
        self._header: List[str] = []
        self._rows: List[List[str]] = []
        self._t: Optional[np.ndarray] = None
        self._labels: List[str] = []
        self._cols: Dict[str, np.ndarray] = {}

        self._build_ui()

    def _build_ui(self) -> None:
        root = QVBoxLayout(self)
        root.setContentsMargins(6, 6, 6, 6)
        root.setSpacing(8)

        top = QHBoxLayout()
        self.btn_open = QPushButton("Open CSVâ€¦")
        self.btn_open.clicked.connect(self.on_open)
        self.lbl_file = QLabel("No file loaded")
        self.lbl_file.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        top.addWidget(self.btn_open)

        top.addStretch(1)
        top.addWidget(self.lbl_file)
        root.addLayout(top)

        # Preview controls
        prev_bar = QHBoxLayout()
        prev_bar.addWidget(QLabel("Preview column:"))
        self.cmb_col = QComboBox()
        self.cmb_col.currentIndexChanged.connect(self._redraw_preview)
        prev_bar.addWidget(self.cmb_col)
        prev_bar.addStretch(1)
        root.addLayout(prev_bar)

        # Preview plot
        self.preview = pg.PlotWidget()
        self.preview.showGrid(x=True, y=True, alpha=0.25)
        self.preview.setLabel("bottom", "t", units="s")
        root.addWidget(self.preview)

        # Table for ranges
        self.table = QTableWidget(0, 3)
        self.table.setHorizontalHeaderLabels(["Start (s)", "End (s)", "Output name"])
        self.table.setSelectionBehavior(QAbstractItemView.SelectRows)
        root.addWidget(self.table)

        rowbar = QHBoxLayout()
        self.btn_add = QPushButton("Add Row")
        self.btn_del = QPushButton("Delete Selected")
        self.btn_add.clicked.connect(self.on_add)
        self.btn_del.clicked.connect(self.on_del)
        rowbar.addWidget(self.btn_add)
        rowbar.addWidget(self.btn_del)
        rowbar.addStretch(1)
        root.addLayout(rowbar)

        self.btn_split = QPushButton("Split & Save to ./outputs")
        self.btn_split.clicked.connect(self.on_split)
        root.addWidget(self.btn_split)

        self.setLayout(root)

    # ------------- File -------------
    def on_open(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, "Open CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "r", newline="", encoding="utf-8") as f:
                rdr = csv.reader(f)
                header = next(rdr)
                if len(header) < 3 or header[0] != "timestamp_iso" or header[1] != "t_rel_s":
                    raise ValueError("Unexpected CSV header. Expect 'timestamp_iso,t_rel_s,...'")
                labels = header[2:]
                rows: List[List[str]] = []
                t: List[float] = []
                cols: Dict[str, List[float]] = {lab: [] for lab in labels}
                for row in rdr:
                    if not row:
                        continue
                    rows.append(row)
                    try:
                        t.append(float(row[1]))
                    except Exception:
                        t.append(np.nan)
                    for i, lab in enumerate(labels, start=2):
                        try:
                            v = row[i]
                            cols[lab].append(float(v) if v != '' else np.nan)
                        except Exception:
                            cols[lab].append(np.nan)

            self._path = path
            self._header = header
            self._rows = rows
            self._labels = labels
            self._t = np.asarray(t, dtype=float)
            self._cols = {k: np.asarray(v, dtype=float) for k, v in cols.items()}

            self.lbl_file.setText(os.path.basename(path) + f"  (rows: {len(rows)})")
            self.table.setRowCount(0)

            # Fill preview combobox
            self.cmb_col.blockSignals(True)
            self.cmb_col.clear()
            self.cmb_col.addItems(self._labels)
            self.cmb_col.blockSignals(False)

            self._redraw_preview()
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))

    def _redraw_preview(self) -> None:
        self.preview.clear()
        if self._t is None or not self._labels:
            return
        lab = self.cmb_col.currentText() if self.cmb_col.count() else None
        if not lab:
            return
        y = self._cols.get(lab)
        if y is None:
            return
        mask = np.isfinite(self._t) & np.isfinite(y)
        if not np.any(mask):
            return
        self.preview.plot(self._t[mask], y[mask], pen=pg.mkPen(width=1.6))

    # ------------- Table -------------
    def on_add(self) -> None:
        r = self.table.rowCount()
        self.table.insertRow(r)
        self.table.setItem(r, 0, QTableWidgetItem("0.0"))
        self.table.setItem(r, 1, QTableWidgetItem("1.0"))
        base = f"slice_{r+1:02d}"
        self.table.setItem(r, 2, QTableWidgetItem(base))

    def on_del(self) -> None:
        rows = sorted({i.row() for i in self.table.selectedIndexes()}, reverse=True)
        for r in rows:
            self.table.removeRow(r)

    # ------------- Split -------------
    def on_split(self) -> None:
        if self._t is None or self._path is None:
            QMessageBox.information(self, "No file", "Load a CSV first.")
            return

        os.makedirs("outputs", exist_ok=True)
        tmax = float(np.nanmax(self._t)) if self._t.size else 0.0

        n_saved = 0
        for r in range(self.table.rowCount()):
            try:
                t0 = float(self.table.item(r, 0).text())
                t1 = float(self.table.item(r, 1).text())
                name = _safe_name(self.table.item(r, 2).text())
            except Exception:
                QMessageBox.warning(self, "Invalid row", f"Row {r+1} has invalid values.")
                continue

            if not (0.0 <= t0 < t1 <= max(tmax, t1)):
                QMessageBox.warning(self, "Invalid range", f"Row {r+1}: check Start/End times.")
                continue

            mask = (self._t >= t0) & (self._t <= t1)
            idx = np.nonzero(mask)[0]
            if idx.size == 0:
                QMessageBox.information(self, "Empty slice", f"Row {r+1}: no samples in range.")
                continue

            out_path = os.path.join("outputs", name if name.lower().endswith('.csv') else name + ".csv")
            try:
                with open(out_path, "w", newline="", encoding="utf-8") as f:
                    wr = csv.writer(f)
                    wr.writerow(self._header)
                    for i in idx.tolist():
                        wr.writerow(self._rows[i])
                n_saved += 1
            except Exception as e:
                QMessageBox.critical(self, "Write error", f"{name}: {e}")

        QMessageBox.information(self, "Done", f"Saved {n_saved} file(s) to ./outputs/")

------------------------------ END OF FILE ------------------------------

============================= ui\recorder\view_csv_tab.py
# File: view_csv_tab.py (ext: .py
# Dir : ui\recorder\
# Size: 9848 bytes
# Time: 29/09/2025 11:47
============================= ui\recorder\view_csv_tab.py
from __future__ import annotations

import csv
from typing import List, Dict, Optional

import numpy as np
import pyqtgraph as pg

from PySide6.QtCore import Qt
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QPushButton, QLabel,
    QDoubleSpinBox, QFileDialog, QGridLayout, QCheckBox, QMessageBox,
    QGroupBox
)

from core.state import AppState


class ViewCSVTab(QWidget):
    """
    Offline visualization of a previously recorded CSV (Capture format).

    Behavior per your request:
      â€¢ No playback. Just plot the loaded data.
      â€¢ Controls:
          - Open CSVâ€¦
          - Global X range: Xmin (s), Xmax (s), and Auto-X
          - Per-plot Y range: click a plot to select it, then set Ymin/Ymax or Auto-Y
          - Enable/Disable channels

    Assumes CSV header: timestamp_iso, t_rel_s, <compact labels...>
    """

    def __init__(self, state: AppState, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.state = state

        self._t: Optional[np.ndarray] = None
        self._cols: Dict[str, np.ndarray] = {}
        self._labels: List[str] = []

        self._plots: List[pg.PlotWidget] = []
        self._curves: Dict[str, pg.PlotDataItem] = {}
        self._chb: Dict[str, QCheckBox] = {}

        self._selected_plot_index: Optional[int] = None

        self._build_ui()

    # ---------------- UI ----------------
    def _build_ui(self) -> None:
        root = QVBoxLayout(self)
        root.setContentsMargins(6, 6, 6, 6)
        root.setSpacing(8)

        # Top bar
        top = QHBoxLayout()

        self.btn_open = QPushButton("Open CSVâ€¦")
        self.btn_open.clicked.connect(self.on_open)
        top.addWidget(self.btn_open)

        # Global X controls
        top.addWidget(QLabel("X min (s):"))
        self.spin_xmin = QDoubleSpinBox(); self.spin_xmin.setRange(-1e12, 1e12); self.spin_xmin.setDecimals(6)
        self.spin_xmin.valueChanged.connect(self._apply_x_range)
        top.addWidget(self.spin_xmin)

        top.addWidget(QLabel("X max (s):"))
        self.spin_xmax = QDoubleSpinBox(); self.spin_xmax.setRange(-1e12, 1e12); self.spin_xmax.setDecimals(6)
        self.spin_xmax.valueChanged.connect(self._apply_x_range)
        top.addWidget(self.spin_xmax)

        self.btn_auto_x = QPushButton("Auto X")
        self.btn_auto_x.clicked.connect(self._auto_x)
        top.addWidget(self.btn_auto_x)

        # Per-plot Y controls (apply to selected plot)
        top.addSpacing(12)
        top.addWidget(QLabel("Selected plot Y min:"))
        self.spin_ymin = QDoubleSpinBox(); self.spin_ymin.setRange(-1e12, 1e12); self.spin_ymin.setDecimals(6)
        self.spin_ymin.valueChanged.connect(self._apply_selected_y_range)
        top.addWidget(self.spin_ymin)

        top.addWidget(QLabel("Y max:"))
        self.spin_ymax = QDoubleSpinBox(); self.spin_ymax.setRange(-1e12, 1e12); self.spin_ymax.setDecimals(6)
        self.spin_ymax.valueChanged.connect(self._apply_selected_y_range)
        top.addWidget(self.spin_ymax)

        self.btn_auto_y = QPushButton("Auto Y (selected)")
        self.btn_auto_y.clicked.connect(self._auto_selected_y)
        top.addWidget(self.btn_auto_y)

        top.addStretch(1)
        self.lbl_info = QLabel("No file loaded")
        self.lbl_info.setAlignment(Qt.AlignRight | Qt.AlignVCenter)
        top.addWidget(self.lbl_info)

        root.addLayout(top)

        # Channel enable toggles
        grp = QGroupBox("Channels")
        h = QHBoxLayout(grp)
        self._toggle_box = h
        root.addWidget(grp)

        # 3x3 grid plots
        grid = QGridLayout()
        grid.setSpacing(6)
        for r in range(3):
            for c in range(3):
                pw = pg.PlotWidget()
                pw.showGrid(x=True, y=True, alpha=0.25)
                pw.setLabel("bottom", "t", units="s")
                pw.setMouseEnabled(x=True, y=True)
                idx = len(self._plots)
                pw.scene().sigMouseClicked.connect(lambda ev, i=idx: self._on_plot_clicked(i))
                self._plots.append(pw)
                grid.addWidget(pw, r, c)
        root.addLayout(grid)

        self.setLayout(root)

    # ---------------- File I/O ----------------
    def on_open(self) -> None:
        path, _ = QFileDialog.getOpenFileName(self, "Open CSV", "", "CSV Files (*.csv)")
        if not path:
            return
        try:
            with open(path, "r", newline="", encoding="utf-8") as f:
                rdr = csv.reader(f)
                header = next(rdr)
                if len(header) < 3 or header[0] != "timestamp_iso" or header[1] != "t_rel_s":
                    raise ValueError("Unexpected CSV header. Expect 'timestamp_iso,t_rel_s,...'")
                labels = header[2:]
                t_arr: List[float] = []
                cols: Dict[str, List[float]] = {lab: [] for lab in labels}
                for row in rdr:
                    if not row:
                        continue
                    try:
                        t_arr.append(float(row[1]))
                        for i, lab in enumerate(labels, start=2):
                            v = row[i]
                            cols[lab].append(float(v) if v != '' else np.nan)
                    except Exception:
                        continue

            t = np.asarray(t_arr, dtype=float)
            self._t = t
            self._cols = {k: np.asarray(v, dtype=float) for k, v in cols.items()}
            self._labels = labels

            self._rebuild_toggles()

            # Initial X and Y ranges
            if t.size > 0:
                self.spin_xmin.blockSignals(True); self.spin_xmax.blockSignals(True)
                self.spin_xmin.setValue(float(np.nanmin(t)))
                self.spin_xmax.setValue(float(np.nanmax(t)))
                self.spin_xmin.blockSignals(False); self.spin_xmax.blockSignals(False)

            self._redraw_all()
            dur = (t[-1] - t[0]) if t.size > 1 else 0.0
            self.lbl_info.setText(f"{len(t)} rows Â· {len(labels)} channels Â· dur={dur:.2f}s")
        except Exception as e:
            QMessageBox.critical(self, "Load error", str(e))

    def _rebuild_toggles(self) -> None:
        # clear toggles
        while self._toggle_box.count():
            item = self._toggle_box.takeAt(0)
            w = item.widget()
            if w:
                w.setParent(None)
        self._chb.clear()

        # add toggles
        for i, lab in enumerate(self._labels):
            cb = QCheckBox(lab)
            cb.setChecked(True)
            cb.stateChanged.connect(self._redraw_all)
            self._chb[lab] = cb
            self._toggle_box.addWidget(cb)

        # quick toggles
        btn_all = QPushButton("Enable All")
        btn_all.clicked.connect(lambda: self._set_all(True))
        btn_none = QPushButton("Enable None")
        btn_none.clicked.connect(lambda: self._set_all(False))
        self._toggle_box.addWidget(btn_all)
        self._toggle_box.addWidget(btn_none)
        self._toggle_box.addStretch(1)

    def _set_all(self, enabled: bool) -> None:
        for cb in self._chb.values():
            cb.blockSignals(True)
            cb.setChecked(enabled)
            cb.blockSignals(False)
        self._redraw_all()

    # ---------------- Plotting ----------------
    def _on_plot_clicked(self, idx: int) -> None:
        self._selected_plot_index = idx
        # lightly indicate selection
        for i, pw in enumerate(self._plots):
            pw.setTitle("Selected" if i == idx else "")

    def _apply_x_range(self) -> None:
        xmin = float(self.spin_xmin.value())
        xmax = float(self.spin_xmax.value())
        if xmax <= xmin:
            return
        for pw in self._plots:
            try:
                pw.enableAutoRange('x', False)
                pw.setXRange(xmin, xmax, padding=0)
            except Exception:
                pass

    def _auto_x(self) -> None:
        for pw in self._plots:
            try:
                pw.enableAutoRange('x', True)
            except Exception:
                pass

    def _apply_selected_y_range(self) -> None:
        if self._selected_plot_index is None:
            return
        ymin = float(self.spin_ymin.value())
        ymax = float(self.spin_ymax.value())
        if ymax <= ymin:
            return
        pw = self._plots[self._selected_plot_index]
        try:
            pw.enableAutoRange('y', False)
            pw.setYRange(ymin, ymax, padding=0)
        except Exception:
            pass

    def _auto_selected_y(self) -> None:
        if self._selected_plot_index is None:
            return
        pw = self._plots[self._selected_plot_index]
        try:
            pw.enableAutoRange('y', True)
        except Exception:
            pass

    def _redraw_all(self) -> None:
        if self._t is None:
            return
        t = self._t

        # clear plots and curves
        for pw in self._plots:
            pw.clear()
        self._curves.clear()

        enabled = [lab for lab, cb in self._chb.items() if cb.isChecked()]
        if not enabled:
            return

        # draw enabled channels distributed across plot widgets
        for i, lab in enumerate(enabled):
            pw = self._plots[i % len(self._plots)]
            y = self._cols.get(lab)
            if y is None:
                continue
            curve = pw.plot(t, y, pen=pg.mkPen(width=1.8))
            self._curves[lab] = curve

        # Apply current X range if not in auto
        self._apply_x_range()

------------------------------ END OF FILE ------------------------------

============================= ui\styles.py
# File: styles.py (ext: .py
# Dir : ui\
# Size: 775 bytes
# Time: 16/09/2025 08:39
============================= ui\styles.py
"""Global styles for the application.

This module defines a function to apply a simple Qt stylesheet to the
application.  You can modify the CSS here to adjust font sizes, colours
and spacing throughout the GUI.
"""

from __future__ import annotations

from PySide6.QtWidgets import QWidget


def apply_styles(widget: QWidget) -> None:
    """Apply a minimal stylesheet to the given widget and its children."""
    widget.setStyleSheet(
        """
        QWidget {
            font-size: 12pt;
        }
        QPushButton {
            padding: 4px 6px;
        }
        QDoubleSpinBox, QSpinBox {
            min-width: 60px;
        }
        QComboBox {
            min-width: 80px;
        }
        QLabel {
            color: #222222;
        }
        """
    )

------------------------------ END OF FILE ------------------------------

============================= ui\tab_fft.py
# File: tab_fft.py (ext: .py
# Dir : ui\
# Size: 10945 bytes
# Time: 25/09/2025 09:53
============================= ui\tab_fft.py
# ui/tab_fft.py
from __future__ import annotations

from typing import List, Tuple
import numpy as np
import pyqtgraph as pg

from PySide6.QtCore import QTimer, Qt
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QGridLayout, QLabel, QPushButton,
    QDoubleSpinBox, QCheckBox, QComboBox, QSpinBox
)

from core.state import AppState
from data.mqtt_source import MQTTSource
from sonify.notes_method import one_sided_fft, top_n_freqs  # robust, Hann-windowed one-sided FFT + peak picker
from util.calibration import apply_global_and_scale  # <-- UNIFORM correction


class FFTTab(QWidget):
    """
    Single-panel FFT viewer that can overlay the spectra of all 9 slots.
    - Top bar: window(s), max Hz, detrend mode, normalize, Start/Stop, Show all/none
    - One pyqtgraph plot, 9 colored curves, per-channel checkboxes
    - NEW: peak picking (vertical markers + optional labels), configurable N peaks
    """

    def __init__(self, state: AppState, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.state = state
        self._timer: QTimer | None = None
        self._running: bool = False

        self.plot: pg.PlotWidget | None = None
        self.curves: List[pg.PlotDataItem] = []
        self.checks: List[QCheckBox] = []

        # Peak overlay graphics per slot
        self.peak_lines: List[List[pg.InfiniteLine]] = [[] for _ in range(9)]
        self.peak_labels: List[List[pg.TextItem]] = [[] for _ in range(9)]

        self._last_fs: float | None = None

        self._build_ui()

    def _build_ui(self) -> None:
        root = QVBoxLayout(self)
        root.setContentsMargins(6, 6, 6, 6)
        root.setSpacing(6)

        top = QHBoxLayout()
        top.addWidget(QLabel("Window (s):"))
        self.spin_window = QDoubleSpinBox()
        self.spin_window.setRange(0.2, 60.0)
        self.spin_window.setSingleStep(0.5)
        self.spin_window.setValue(5.0)
        top.addWidget(self.spin_window)

        top.addWidget(QLabel("Max Hz:"))
        self.spin_max_hz = QDoubleSpinBox()
        self.spin_max_hz.setRange(1.0, 1e6)
        self.spin_max_hz.setDecimals(1)
        self.spin_max_hz.setSingleStep(1.0)
        self.spin_max_hz.setValue(10.0)
        top.addWidget(self.spin_max_hz)

        top.addWidget(QLabel("Detrend:"))
        self.cmb_detrend = QComboBox()
        self.cmb_detrend.addItems(["Mean (DC remove)", "Linear", "None"])
        self.cmb_detrend.setCurrentIndex(0)
        self.cmb_detrend.currentIndexChanged.connect(self._refresh_once)
        top.addWidget(self.cmb_detrend)

        self.chk_norm = QCheckBox("Normalize amplitudes")
        self.chk_norm.setChecked(True)
        top.addWidget(self.chk_norm)

        # --- Peak picking controls ---
        self.chk_peaks = QCheckBox("Show peaks")
        self.chk_peaks.setChecked(True)
        top.addWidget(self.chk_peaks)

        top.addWidget(QLabel("Peaks:"))
        self.spin_npeaks = QSpinBox()
        self.spin_npeaks.setRange(1, 12)
        self.spin_npeaks.setValue(3)
        top.addWidget(self.spin_npeaks)

        self.chk_peak_labels = QCheckBox("Label peaks")
        self.chk_peak_labels.setChecked(False)
        top.addWidget(self.chk_peak_labels)
        # -----------------------------

        self.btn_start = QPushButton("Start")
        self.btn_start.clicked.connect(self._on_start_stop)
        top.addWidget(self.btn_start)

        self.btn_all = QPushButton("Show all")
        self.btn_all.clicked.connect(lambda: self._set_all_checks(True))
        top.addWidget(self.btn_all)

        self.btn_none = QPushButton("Show none")
        self.btn_none.clicked.connect(lambda: self._set_all_checks(False))
        top.addWidget(self.btn_none)

        top.addStretch(1)
        root.addLayout(top)

        self.plot = pg.PlotWidget(parent=self)
        self.plot.showGrid(x=True, y=True, alpha=0.3)
        self.plot.setLabel('left', "Amplitude")
        self.plot.setLabel('bottom', "Frequency [Hz]")
        self.plot.setMouseEnabled(x=False, y=False)
        self.plot.addLegend(offset=(10, 10))
        root.addWidget(self.plot, 1)

        grid = QGridLayout()
        grid.setSpacing(4)
        self.curves = []
        self.checks = []
        for idx in range(9):
            name = self.state.channels[idx].name
            pen = pg.mkPen(color=pg.intColor(idx, hues=9, values=1, maxValue=255), width=1.6)
            curve = self.plot.plot([], [], pen=pen, name=f"Slot {idx} â€” {name}")
            self.curves.append(curve)

            chk = QCheckBox(f"{idx}: {name}")
            chk.setChecked(True)
            chk.stateChanged.connect(self._refresh_once)
            self.checks.append(chk)

            r, c = divmod(idx, 3)
            grid.addWidget(chk, r, c)
        root.addLayout(grid)

        # Reactivity
        self.spin_window.valueChanged.connect(self._refresh_once)
        self.spin_max_hz.valueChanged.connect(self._refresh_once)
        self.chk_norm.stateChanged.connect(self._refresh_once)
        self.chk_peaks.stateChanged.connect(self._refresh_once)
        self.spin_npeaks.valueChanged.connect(self._refresh_once)
        self.chk_peak_labels.stateChanged.connect(self._refresh_once)

    def _set_all_checks(self, val: bool) -> None:
        for chk in self.checks:
            chk.blockSignals(True)
            chk.setChecked(val)
            chk.blockSignals(False)
        self._refresh_once()

    def _on_start_stop(self) -> None:
        if not self._running:
            try:
                self.state.start_source()
            except Exception:
                self.btn_start.setText("Start")
                return
            if self._timer is None:
                self._timer = QTimer(self)
                self._timer.timeout.connect(self._refresh_once)
            self._timer.start(250)
            self._running = True
            self.btn_start.setText("Stop")
            self._refresh_once()
        else:
            if self._timer:
                self._timer.stop()
            self._running = False
            self.btn_start.setText("Start")

    def _current_fs(self) -> float:
        src = self.state.ensure_source()
        if isinstance(src, MQTTSource):
            fs = float(src.estimated_hz or 20.0)
        else:
            fs = 20.0
        return max(1e-6, fs)

    def _read_window(self) -> dict[str, np.ndarray]:
        src = self.state.source
        if src is None:
            return {f"slot_{i}": np.array([]) for i in range(9)}
        window_s = float(self.spin_window.value())
        try:
            return src.read(window_s)
        except Exception:
            return {f"slot_{i}": np.array([]) for i in range(9)}

    def _clear_peaks_for_slot(self, i: int) -> None:
        """Remove existing peak lines and labels for slot i."""
        # Remove lines
        for ln in self.peak_lines[i]:
            try:
                self.plot.removeItem(ln)
            except Exception:
                pass
        self.peak_lines[i].clear()
        # Remove labels
        for txt in self.peak_labels[i]:
            try:
                self.plot.removeItem(txt)
            except Exception:
                pass
        self.peak_labels[i].clear()

    def _add_peak_marker(self, i: int, f0: float, label: str | None, color_pen: pg.mkPen) -> None:
        """Add a vertical line (and optional label) at frequency f0 for slot i."""
        line_pen = pg.mkPen(color=color_pen.color(), width=1, style=Qt.DashLine)
        ln = pg.InfiniteLine(pos=float(f0), angle=90, movable=False, pen=line_pen)
        self.plot.addItem(ln)
        self.peak_lines[i].append(ln)

        if label and self.chk_peak_labels.isChecked():
            # Place label at top of current view, slightly inset
            txt = pg.TextItem(text=label, color=color_pen.color(), anchor=(0.3, 1.0))
            self.plot.addItem(txt)
            vb = self.plot.getViewBox()
            try:
                x_min, x_max = vb.viewRange()[0]
                y_min, y_max = vb.viewRange()[1]
            except Exception:
                x_min, x_max = 0.0, float(self.spin_max_hz.value())
                y_min, y_max = 0.0, 1.0
            txt.setPos(float(f0), y_max)
            self.peak_labels[i].append(txt)

    def _refresh_once(self) -> None:
        data = self._read_window()
        fs = self._current_fs()
        max_hz = float(self.spin_max_hz.value())
        self.plot.setXRange(0.0, max_hz, padding=0.0)

        # clear all existing peak annotations before redrawing
        for i in range(9):
            self._clear_peaks_for_slot(i)

        for i in range(9):
            y_raw = np.asarray(data.get(f"slot_{i}", np.array([])), dtype=float).ravel()
            y = apply_global_and_scale(self.state, i, y_raw)  # <-- UNIFORM correction

            if y.size < 2 or not self.checks[i].isChecked():
                self.curves[i].setData([], [])
                continue

            f, A = one_sided_fft(y, fs, detrend=self._detrend_mode())
            m = f <= max_hz
            f_plot = f[m]; A_plot = A[m]

            if self.chk_norm.isChecked():
                peak = float(np.max(A_plot)) if A_plot.size else 0.0
                if peak > 0:
                    A_plot = A_plot / peak

            self.curves[i].setData(f_plot, A_plot)

            # Peak picking overlay
            if self.chk_peaks.isChecked():
                n = int(self.spin_npeaks.value())
                # Use the same robust picker used by fft_view
                try:
                    cand = top_n_freqs(y, float(fs), max(1, n), detrend=self._detrend_mode())
                except Exception:
                    cand = []

                # Filter peaks to the current visible band
                cand = [float(x) for x in cand if 0.0 < float(x) <= max_hz]

                # If multiple candidates map to the same FFT bin, deduplicate by frequency value
                if cand:
                    # Create a pen for this slot (same color as the curve)
                    pen = self.curves[i].opts.get("pen", pg.mkPen("w"))

                    # Add markers (limit to N shown after filtering)
                    for f0 in cand[:n]:
                        # Optional label text (Hz with one decimal)
                        label = f"{f0:.1f} Hz" if self.chk_peak_labels.isChecked() else None
                        self._add_peak_marker(i, f0, label, pen)

    def _detrend_mode(self) -> str:
        t = self.cmb_detrend.currentText().lower()
        if "linear" in t:
            return "linear"
        if "none" in t:
            return "none"
        return "mean"

------------------------------ END OF FILE ------------------------------

============================= ui\tab_recorder.py
# File: tab_recorder.py (ext: .py
# Dir : ui\
# Size: 1213 bytes
# Time: 29/09/2025 11:07
============================= ui\tab_recorder.py
from __future__ import annotations

from PySide6.QtWidgets import QWidget, QVBoxLayout, QTabWidget

from .recorder.capture_tab import CaptureTab
from .recorder.view_csv_tab import ViewCSVTab
from .recorder.split_csv_tab import SplitCSVTab
from .recorder.fft_tab import FFTTab

from core.state import AppState  # existing


class RecorderTab(QWidget):
    """
    Wrapper tab that hosts four sub-tabs:
      - Capture (auto sampling; 3 sensors Ã— 3 signals)
      - View CSV (static plotting with per-plot axis control)
      - Split CSV (preview any column; split full CSV by time)
      - FFT (load CSV, choose channel, view FFT)
    """

    def __init__(self, state: AppState, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.state = state

        tabs = QTabWidget(self)
        tabs.addTab(CaptureTab(self.state, parent=self), "Capture")
        tabs.addTab(ViewCSVTab(self.state, parent=self), "View CSV")
        tabs.addTab(SplitCSVTab(self.state, parent=self), "Split CSV")
        tabs.addTab(FFTTab(self.state, parent=self), "FFT")

        layout = QVBoxLayout(self)
        layout.addWidget(tabs)
        self.setLayout(layout)

------------------------------ END OF FILE ------------------------------

============================= ui\tab_signals.py
# File: tab_signals.py (ext: .py
# Dir : ui\
# Size: 12069 bytes
# Time: 16/11/2025 12:16
============================= ui\tab_signals.py
from __future__ import annotations

from typing import List
import os
import numpy as np

from PySide6.QtCore import QTimer
from PySide6.QtGui import QColor, QPixmap
from PySide6.QtWidgets import (
    QWidget, QVBoxLayout, QHBoxLayout, QGridLayout, QLabel, QPushButton,
    QDoubleSpinBox, QMessageBox, QComboBox, QDialog, QDialogButtonBox,
)

from core.state import AppState
from data.mqtt_source import MQTTSource
from plotting.plotter import create_plot, update_curve
from ui.mqtt_settings import MQTTSettingsDialog
import pyqtgraph as pg
from util.calibration import apply_global_and_scale  # <-- UNIFORM correction

PALETTE = [
    "#1f77b4", "#ff7f0e", "#2ca02c",
    "#d62728", "#9467bd", "#8c564b",
    "#e377c2", "#7f7f7f", "#17becf",
]


class SignalsTab(QWidget):
    """Tab displaying signals from a data source in a 3Ã—3 grid."""

    def __init__(self, state: AppState, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.state = state
        self._timer: QTimer | None = None
        self.running = False

        self.plots: List[object] = []
        self.curves: List[object] = []
        self.controls: List["ChannelControls"] = []

        self._last_expected_n: int | None = None

        self._build_ui()

    @staticmethod
    def _slot_is_gyro(slot_index: int) -> bool:
        return slot_index in (2, 5, 8)

    @staticmethod
    def _slot_unit(slot_index: int) -> str:
        return "deg/s" if SignalsTab._slot_is_gyro(slot_index) else "m/sÂ²"

    def _build_ui(self) -> None:
        layout = QVBoxLayout(self)
        layout.setContentsMargins(4, 4, 4, 4)
        layout.setSpacing(6)

        top_row = QHBoxLayout()
        top_row.setSpacing(6)

        top_row.addWidget(QLabel("Sensors data (MQTT):"))

        top_row.addWidget(QLabel("Window (s):"))
        self.spin_window = QDoubleSpinBox()
        self.spin_window.setRange(0.1, 60.0)
        self.spin_window.setSingleStep(0.5)
        self.spin_window.setValue(5.0)
        top_row.addWidget(self.spin_window)

        self.btn_start = QPushButton("Start")
        self.btn_start.clicked.connect(self.on_start_stop)
        top_row.addWidget(self.btn_start)

        self.btn_enable_all = QPushButton("Enable All")
        self.btn_enable_all.clicked.connect(self.on_enable_all)
        top_row.addWidget(self.btn_enable_all)

        self.btn_disable_all = QPushButton("Disable All")
        self.btn_disable_all.clicked.connect(self.on_disable_all)
        top_row.addWidget(self.btn_disable_all)

        self.btn_reset_y_all = QPushButton("Reset Y All")
        self.btn_reset_y_all.clicked.connect(self.on_reset_y_all)
        top_row.addWidget(self.btn_reset_y_all)

        self.btn_mqtt_settings = QPushButton("MQTT Settingsâ€¦")
        self.btn_mqtt_settings.clicked.connect(self.open_mqtt_settings)
        top_row.addWidget(self.btn_mqtt_settings)

        # Removed: manual frequency controls (cmb_hz, btn_set_hz)
        # Add a read-only label to display the source-estimated sampling rate.
        self.lbl_fs = QLabel("fs: â€” Hz")
        top_row.addWidget(self.lbl_fs)

        self.btn_cal = QPushButton("Calibrate (zero-mean)")
        self.btn_cal.clicked.connect(self.do_calibrate_global)
        top_row.addWidget(self.btn_cal)

        self.lbl_rec = QLabel(f"Recorder: {self.state.mqtt.recorder}")
        top_row.addWidget(self.lbl_rec)

        top_row.addWidget(QLabel("Fix Y Â±:"))
        self.spin_y_limit = QDoubleSpinBox()
        self.spin_y_limit.setRange(0.01, 10000.0)
        self.spin_y_limit.setDecimals(3)
        self.spin_y_limit.setSingleStep(0.05)
        self.spin_y_limit.setValue(5.00)
        top_row.addWidget(self.spin_y_limit)

        self.btn_apply_y = QPushButton("Apply")
        self.btn_apply_y.clicked.connect(self.apply_y_limit)
        top_row.addWidget(self.btn_apply_y)

        self.btn_auto_y = QPushButton("Auto")
        self.btn_auto_y.clicked.connect(self.auto_y_limit)
        top_row.addWidget(self.btn_auto_y)

        self.btn_show_layout = QPushButton("Show sensors layout")
        self.btn_show_layout.clicked.connect(self.show_sensors_layout)
        top_row.addWidget(self.btn_show_layout)

        top_row.addStretch(1)
        layout.addLayout(top_row)

        grid = QGridLayout()
        grid.setSpacing(6)
        for row in range(3):
            for col in range(3):
                idx = row * 3 + col
                cell_widget = QWidget()
                cell_layout = QVBoxLayout(cell_widget)
                cell_layout.setContentsMargins(0, 0, 0, 0)
                cell_layout.setSpacing(2)

                y_label = self._slot_unit(idx)
                plot_widget, curve = create_plot(cell_widget, x_label="Data points", y_label=y_label)
                plot_widget.setFixedHeight(120)
                cell_layout.addWidget(plot_widget)
                self.plots.append(plot_widget)
                self.curves.append(curve)
                curve.setPen(pg.mkPen(PALETTE[idx % len(PALETTE)], width=2.0))

                from .widgets import ChannelControls  # local import to avoid cycles
                ctrl = ChannelControls(idx, self.state, cell_widget)
                self.controls.append(ctrl)
                cell_layout.addWidget(ctrl)

                grid.addWidget(cell_widget, row, col)
        layout.addLayout(grid)

        self.spin_window.valueChanged.connect(lambda _=None: self._apply_expected_xrange())

    def _expected_points(self) -> int:
        window_s = float(self.spin_window.value())
        src = self.state.ensure_source()
        if isinstance(src, MQTTSource):
            hz = float(getattr(src, "estimated_hz", 20.0) or 20.0)
        else:
            hz = 20.0
        n = int(round(max(0.001, window_s) * max(1.0, hz)))
        return max(1, n)

    def _apply_expected_xrange(self) -> None:
        n = self._expected_points()
        if self._last_expected_n == n:
            return
        for plot in self.plots:
            try:
                plot.enableAutoRange('x', False)
                plot.setXRange(0, max(1, n - 1), padding=0)
            except Exception:
                pass
        self._last_expected_n = n

    def on_start_stop(self) -> None:
        if not self.running:
            try:
                self.state.start_source()
            except Exception as e:
                QMessageBox.critical(self, "MQTT start failed", str(e))
                return
            if self._timer is None:
                self._timer = QTimer(self)
                self._timer.timeout.connect(self.update_data)
            self._timer.start(50)
            self.running = True
            self.btn_start.setText("Stop")
            self._apply_expected_xrange()
        else:
            self.running = False
            if self._timer:
                self._timer.stop()
            self.state.stop_source()
            self.btn_start.setText("Start")

    def on_enable_all(self) -> None:
        for ch_cfg in self.state.channels:
            ch_cfg.enabled = True
        for ctrl in self.controls:
            ctrl.refresh()

    def on_disable_all(self) -> None:
        for ch_cfg in self.state.channels:
            ch_cfg.enabled = False
        for ctrl in self.controls:
            ctrl.refresh()

    def on_reset_y_all(self) -> None:
        for ch_cfg in self.state.channels:
            ch_cfg.y_zoom = 1.0

    def update_data(self) -> None:
        # Update read-only display of estimated sampling rate from source status.
        src = self.state.source
        dev_hz = 0.0
        if isinstance(src, MQTTSource):
            try:
                dev_hz = float(src.get_rate().hz_effective)
            except Exception:
                dev_hz = 0.0
        self.lbl_fs.setText(f"Device: ~{dev_hz:.1f} Hz")

        if isinstance(src, MQTTSource):
            try:
                res = src.get_rate_apply_result()  # tuple(status, hz, t)
                status, hz_req, t = res
                if status == "ok":
                    self.lbl_fs.setText(f"Device: ~{src.get_rate().hz_effective:.1f} Hz Â· Last set {hz_req:.0f} Hz âœ“")
                elif status == "timeout":
                    self.lbl_fs.setText(f"Device: ~{src.get_rate().hz_effective:.1f} Hz Â· Set {hz_req:.0f} Hz timed out")
            except Exception:
                pass

        self._apply_expected_xrange()
        window_s = float(self.spin_window.value())
        if src is None:
            return
        try:
            data = src.read(window_s)
        except Exception:
            self.on_start_stop()
            data = {f"slot_{i}": np.array([]) for i in range(9)}

        for i in range(9):
            ch_cfg = self.state.channels[i]
            y = data.get(f"slot_{i}", np.array([]))

            if ch_cfg.enabled and np.size(y) > 0:
                y_cal = apply_global_and_scale(self.state, i, y)  # <-- UNIFORM correction
            else:
                y_cal = np.array([])

            update_curve(self.curves[i], y_cal, ch_cfg.y_zoom)
            plot = self.plots[i]
            plot.setBackground(QColor(255, 255, 255) if ch_cfg.enabled else QColor(245, 245, 245))

    def open_mqtt_settings(self) -> None:
        dlg = MQTTSettingsDialog(self.state, self)
        if dlg.exec() == QDialog.Accepted:
            self.lbl_rec.setText(f"Recorder: {self.state.mqtt.recorder}")
            if self.running:
                self.on_start_stop()
            self.state.stop_source()
            self.state.source = None
            self._last_expected_n = None
            self._apply_expected_xrange()

    def do_calibrate_global(self) -> None:
        src = self.state.source
        if src is None:
            return
        window_s = float(self.spin_window.value())
        data = src.read(window_s)
        offsets: list[float] = []
        for i in range(9):
            y = data.get(f"slot_{i}", np.array([]))
            offsets.append(float(np.mean(y)) if np.size(y) > 0 else 0.0)
        self.state.global_cal.offsets = offsets
        self.state.global_cal.enabled = True

    def apply_y_limit(self) -> None:
        val = float(self.spin_y_limit.value())
        if val <= 0:
            return
        for plot in self.plots:
            try:
                plot.enableAutoRange('y', False)
                plot.setYRange(-val, val, padding=0)
            except Exception:
                pass

    def auto_y_limit(self) -> None:
        for plot in self.plots:
            try:
                plot.enableAutoRange('y', True)
            except Exception:
                pass

    def show_sensors_layout(self) -> None:
        candidate_paths = [
            os.path.join(os.getcwd(), "images", "sensors.jpg"),
            os.path.join(os.path.dirname(__file__), "..", "images", "sensors.jpg"),
        ]
        img_path = next((p for p in candidate_paths if os.path.exists(p)), None)
        if not img_path:
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(self, "Image not found", "Could not find images/sensors.jpg")
            return

        dlg = QDialog(self)
        dlg.setWindowTitle("Sensors numbering layout")
        v = QVBoxLayout(dlg)
        lbl = QLabel()
        pix = QPixmap(img_path)
        if pix.isNull():
            from PySide6.QtWidgets import QMessageBox
            QMessageBox.warning(self, "Image error", "Failed to load sensors.jpg")
            return
        lbl.setPixmap(pix)
        v.addWidget(lbl)
        btns = QDialogButtonBox(QDialogButtonBox.Close)
        btns.rejected.connect(dlg.reject)
        btns.accepted.connect(dlg.accept)
        v.addWidget(btns)
        dlg.resize(pix.width(), pix.height())
        dlg.exec()

------------------------------ END OF FILE ------------------------------

============================= ui\widgets.py
# File: widgets.py (ext: .py
# Dir : ui\
# Size: 2709 bytes
# Time: 16/09/2025 13:10
============================= ui\widgets.py
"""Reusable user interface components.

This module defines small widgets used in the signals tab. Keeping these
controls in their own module makes it easier to modify their layout or
behaviour without touching the rest of the code.
"""

from __future__ import annotations

from PySide6.QtWidgets import (
    QWidget,
    QCheckBox,
    QDoubleSpinBox,
    QLabel,
    QHBoxLayout,
)

from core.state import AppState


class ChannelControls(QWidget):
    """UI panel for adjusting a single plot slot.

    Each cell in the signals tab consists of a plot stacked above a
    :class:`ChannelControls` instance. This widget exposes a checkbox
    to enable/disable the channel and a spin box for a multiplicative
    scale. Per-channel offsets and Y+ / Yâˆ’ buttons have been removed in
    favour of a global fixed-Y control in the toolbar.
    """

    def __init__(self, idx: int, state: AppState, parent: QWidget | None = None) -> None:
        super().__init__(parent)
        self.idx = idx
        self.state = state
        ch = self.state.channels[idx]

        # Horizontal layout for controls
        layout = QHBoxLayout(self)
        layout.setContentsMargins(0, 0, 0, 0)
        layout.setSpacing(4)

        # Slot title
        self.lbl_title = QLabel(ch.name)
        layout.addWidget(self.lbl_title)

        # Enable checkbox
        self.check_enable = QCheckBox("Enable")
        self.check_enable.setChecked(ch.enabled)
        self.check_enable.stateChanged.connect(self.on_enable_changed)
        layout.addWidget(self.check_enable)

        # Calibration scale (per-channel)
        self.lbl_scale = QLabel("Scale")
        layout.addWidget(self.lbl_scale)
        self.spin_scale = QDoubleSpinBox()
        self.spin_scale.setRange(0.0, 1000.0)
        self.spin_scale.setSingleStep(0.1)
        self.spin_scale.setValue(ch.cal.scale)
        self.spin_scale.valueChanged.connect(self.on_scale_changed)
        layout.addWidget(self.spin_scale)

        # Stretch at end
        layout.addStretch(1)

    def on_enable_changed(self, state: int) -> None:
        self.state.channels[self.idx].enabled = bool(state)

    def on_scale_changed(self, value: float) -> None:
        self.state.channels[self.idx].cal.scale = float(value)

    def refresh(self) -> None:
        """Synchronise widgets from the current state."""
        ch = self.state.channels[self.idx]
        self.check_enable.blockSignals(True)
        self.spin_scale.blockSignals(True)
        try:
            self.check_enable.setChecked(ch.enabled)
            self.spin_scale.setValue(ch.cal.scale)
        finally:
            self.check_enable.blockSignals(False)
            self.spin_scale.blockSignals(False)

------------------------------ END OF FILE ------------------------------

============================= util\__init__.py
# File: __init__.py (ext: .py
# Dir : util\
# Size: 47 bytes
# Time: 16/09/2025 08:39
============================= util\__init__.py
"""Utility modules for Digital Twin Simple."""

------------------------------ END OF FILE ------------------------------

============================= util\__pycache__\__init__.cpython-311.pyc
# File: __init__.cpython-311.pyc (ext: .pyc
# Dir : util\__pycache__\
# Size: 244 bytes
# Time: 16/09/2025 11:17
============================= util\__pycache__\__init__.cpython-311.pyc
§
    FÉh/   ã                   ó
   — d Z dS )z(Utility modules for Digital Twin Simple.N)Ú__doc__© ó    úQC:\Users\Melad\source\repos\DigitalTwin\DigitalTwin\Restructured\util\__init__.pyú<module>r      s   ðØ .Ð .Ð .Ð .r   
------------------------------ END OF FILE ------------------------------

============================= util\__pycache__\__init__.cpython-312.pyc
# File: __init__.cpython-312.pyc (ext: .pyc
# Dir : util\__pycache__\
# Size: 176 bytes
# Time: 20/09/2025 20:49
============================= util\__pycache__\__init__.cpython-312.pyc
Ë
    FÉh/   ã                   ó   — d Z y)z(Utility modules for Digital Twin Simple.N)Ú__doc__© ó    úC:\code\util\__init__.pyú<module>r      s   ðÚ .r   
------------------------------ END OF FILE ------------------------------

============================= util\__pycache__\calibration.cpython-311.pyc
# File: calibration.cpython-311.pyc (ext: .pyc
# Dir : util\__pycache__\
# Size: 1533 bytes
# Time: 18/09/2025 10:56
============================= util\__pycache__\calibration.cpython-311.pyc
§
    ^ÔËhX  ã                  ó.   — d dl mZ d dlZd dlmZ dd„ZdS )é    )ÚannotationsN)ÚAppStateÚstater   ÚidxÚintÚyú
np.ndarrayÚreturnc                ól  — t          j        |t          ¬¦  «                             ¦   «         }|j        dk    r|S 	 | j        j        r"|t          | j        j        |         ¦  «        z
  }n# t          $ r Y nw xY w	 t          | j	        |         j
        j        ¦  «        |z  }n# t          $ r Y nw xY w|S )zí
    Uniform calibration used across the app:
      - If global baseline correction is enabled, subtract per-slot offset.
      - Apply per-channel multiplicative scale.
    Returns a 1-D float array (copy-safe for downstream code).
    )Údtyper   )ÚnpÚasarrayÚfloatÚravelÚsizeÚ
global_calÚenabledÚoffsetsÚ	ExceptionÚchannelsÚcalÚscale)r   r   r   Úarrs       úTC:\Users\Melad\source\repos\DigitalTwin\DigitalTwin\Restructured\util\calibration.pyÚapply_global_and_scaler      sÐ   € õ Œ*QeÐ
$Ñ
$Ô
$×
*Ò
*Ñ
,Ô
,€CØ
„x1‚}€}Øˆ
ðØÔÔ#ð 	=Ø˜eÔ.Ô6°sÔ;Ñ<Ô<Ñ<ˆCøøÝð ð ð àˆðøøøðÝE”N 3Ô'Ô+Ô1Ñ2Ô2°SÑ8ˆˆøÝð ð ð Øˆðøøøà€Js#   ¼.A+ Á+
A8Á7A8Á<'B$ Â$
B1Â0B1)r   r   r   r   r   r	   r
   r	   )Ú
__future__r   Únumpyr   Ú
core.stater   r   © ó    r   ú<module>r!      sS   ðà "Ð "Ð "Ð "Ð "Ð "Ø Ð Ð Ð Ø Ð Ð Ð Ð Ð ðð ð ð ð ð r    
------------------------------ END OF FILE ------------------------------

============================= util\__pycache__\calibration.cpython-312.pyc
# File: calibration.cpython-312.pyc (ext: .pyc
# Dir : util\__pycache__\
# Size: 1392 bytes
# Time: 20/09/2025 20:49
============================= util\__pycache__\calibration.cpython-312.pyc
Ë
    ^ÔËhX  ã                  ó,   — d dl mZ d dlZd dlmZ dd„Zy)é    )ÚannotationsN)ÚAppStatec                ó  — t        j                  |t        ¬«      j                  «       }|j                  dk(  r|S 	 | j
                  j                  r%|t        | j
                  j                  |   «      z
  }	 t        | j                  |   j                  j                  «      |z  }|S # t        $ r Y Œ=w xY w# t        $ r Y |S w xY w)zí
    Uniform calibration used across the app:
      - If global baseline correction is enabled, subtract per-slot offset.
      - Apply per-channel multiplicative scale.
    Returns a 1-D float array (copy-safe for downstream code).
    )Údtyper   )ÚnpÚasarrayÚfloatÚravelÚsizeÚ
global_calÚenabledÚoffsetsÚ	ExceptionÚchannelsÚcalÚscale)ÚstateÚidxÚyÚarrs       úC:\code\util\calibration.pyÚapply_global_and_scaler      s½   € ô *‰*QœeÔ
$×
*Ñ
*Ó
,€CØ
‡xx1‚}Øˆ
ðØ×Ñ×#Ò#Øœ˜e×.Ñ.×6Ñ6°sÑ;Ó<Ñ<ˆCðÜE—N‘N 3Ñ'×+Ñ+×1Ñ1Ó2°SÑ8ˆð €Jøô ò áðûô
 ò ØØ€Jðús#   ¼;B) Á8/B8 Â)	B5Â4B5Â8	CÃC)r   r   r   Úintr   ú
np.ndarrayÚreturnr   )Ú
__future__r   Únumpyr   Ú
core.stater   r   © ó    r   ú<module>r!      s   ðå "Û Ý ôr    
------------------------------ END OF FILE ------------------------------

============================= util\__pycache__\ringbuf.cpython-311.pyc
# File: ringbuf.cpython-311.pyc (ext: .pyc
# Dir : util\__pycache__\
# Size: 3431 bytes
# Time: 16/09/2025 11:17
============================= util\__pycache__\ringbuf.cpython-311.pyc
§
    FÉh!  ã                  ó8   — d Z ddlmZ ddlZ G d„ d¦  «        ZdS )u'  A simple fixedâ€‘size ring buffer for numeric data.

The `RingBuffer` class stores a fixed number of the most recent samples in a
numpy array.  When the buffer fills up it silently overwrites the oldest
samples.  This is useful for implementing moving windows without dynamic
memory allocation.
é    )ÚannotationsNc                  ó2   — e Zd ZdZdd„Zdd	„Zdd„Zdd„ZdS )Ú
RingBufferu‹   Fixedâ€‘length circular buffer for floats.

    Parameters
    ----------
    size : int
        Maximum number of elements to retain.
    ÚsizeÚintÚreturnÚNonec                ó”   — t          |¦  «        | _        t          j        | j        t          ¬¦  «        | _        d| _        d| _        d S )N©Údtyper   F)r   r   ÚnpÚzerosÚfloatÚbufferÚindexÚfull)Úselfr   s     úPC:\Users\Melad\source\repos\DigitalTwin\DigitalTwin\Restructured\util\ringbuf.pyÚ__init__zRingBuffer.__init__   s9   € Ý˜‘I”IˆŒ	Ý”h˜tœyµÐ6Ñ6Ô6ˆŒØˆŒ
ØˆŒ	ˆ	ˆ	ó    Úvaluesúnp.ndarray | list[float]c                óô   — t          j        |t          ¬¦  «                             ¦   «         }|D ]G}t          |¦  «        | j        | j        <   | j        dz   | j        z  | _        | j        dk    rd| _        ŒHdS )z(Append one or more values to the buffer.r   é   r   TN)r   Úasarrayr   Úravelr   r   r   r   )r   r   ÚarrÚvals       r   ÚpushzRingBuffer.push   sv   € åŒj˜¥uÐ-Ñ-Ô-×3Ò3Ñ5Ô5ˆØð 	!ð 	!ˆCÝ&+¨C¡j¤jˆDŒK˜œ
Ñ#Øœ* q™.¨D¬IÑ5ˆDŒJØŒz˜QŠˆØ ”	øð		!ð 	!r   Únú
np.ndarrayc                ó®  — |dk    rt          j        dt          ¬¦  «        S | j        r| j        n| j        }t          t          ||¦  «        ¦  «        }| j        |z
  | j        z  }||z   | j        k    r$| j        |||z   …          	                    ¦   «         S | j        |d…         }| j        d||z   | j        z  …         }t          j
        ||f¦  «        S )z5Return the last ``n`` samples in chronological order.r   r   N)r   Úemptyr   r   r   r   r   Úminr   ÚcopyÚconcatenate)r   r    Úvalid_lengthÚstartÚpart1Úpart2s         r   Úget_lastzRingBuffer.get_last&   sÐ   € àŠ6ˆ6Ý”8˜A¥UÐ+Ñ+Ô+Ð+Ø$(¤IÐ=t”yy°4´:ˆÝ•A|Ñ$Ô$Ñ%Ô%ˆØ”˜a‘ 4¤9Ñ,ˆØ1‰9˜œ	Ò!Ð!Ø”;˜u U¨Q¡Y˜Ô/×4Ò4Ñ6Ô6Ð6à”K   Ô'ˆEØ”KÐ 9 5¨1¡9°´	Ñ"9Ð 9Ô:ˆEÝ”> 5¨% .Ñ1Ô1Ð1r   c                óV   — | j                              d¦  «         d| _        d| _        dS )z,Reset the buffer to its initial empty state.g        r   FN)r   Úfillr   r   )r   s    r   ÚclearzRingBuffer.clear4   s*   € àŒ×Ò˜ÑÔÐØˆŒ
ØˆŒ	ˆ	ˆ	r   N)r   r   r   r	   )r   r   r   r	   )r    r   r   r!   )r   r	   )Ú__name__Ú
__module__Ú__qualname__Ú__doc__r   r   r+   r.   © r   r   r   r      sn   € € € € € ðð ð ð  ð  ð  ð!ð !ð !ð !ð2ð 2ð 2ð 2ðð ð ð ð ð r   r   )r2   Ú
__future__r   Únumpyr   r   r3   r   r   ú<module>r6      sa   ððð ð #Ð "Ð "Ð "Ð "Ð "à Ð Ð Ð ð*ð *ð *ð *ð *ñ *ô *ð *ð *ð *r   
------------------------------ END OF FILE ------------------------------

============================= util\__pycache__\ringbuf.cpython-312.pyc
# File: ringbuf.cpython-312.pyc (ext: .pyc
# Dir : util\__pycache__\
# Size: 3213 bytes
# Time: 20/09/2025 20:49
============================= util\__pycache__\ringbuf.cpython-312.pyc
Ë
    FÉh!  ã                  ó0   — d Z ddlmZ ddlZ G d„ d«      Zy)u'  A simple fixedâ€‘size ring buffer for numeric data.

The `RingBuffer` class stores a fixed number of the most recent samples in a
numpy array.  When the buffer fills up it silently overwrites the oldest
samples.  This is useful for implementing moving windows without dynamic
memory allocation.
é    )ÚannotationsNc                  ó0   — e Zd ZdZdd„Zdd„Zd	d„Zd
d„Zy)Ú
RingBufferu‹   Fixedâ€‘length circular buffer for floats.

    Parameters
    ----------
    size : int
        Maximum number of elements to retain.
    c                ó”   — t        |«      | _        t        j                  | j                  t        ¬«      | _        d| _        d| _        y )N©Údtyper   F)ÚintÚsizeÚnpÚzerosÚfloatÚbufferÚindexÚfull)Úselfr
   s     úC:\code\util\ringbuf.pyÚ__init__zRingBuffer.__init__   s1   € Ü˜“IˆŒ	Ü—h‘h˜tŸy™y´Ô6ˆŒØˆŒ
Øˆ	ó    c                ó  — t        j                  |t        ¬«      j                  «       }|D ]\  }t        |«      | j                  | j
                  <   | j
                  dz   | j                  z  | _        | j
                  dk(  sŒVd| _        Œ^ y)z(Append one or more values to the buffer.r   é   r   TN)r   Úasarrayr   Úravelr   r   r
   r   )r   ÚvaluesÚarrÚvals       r   ÚpushzRingBuffer.push   sj   € äj‰j˜¤uÔ-×3Ñ3Ó5ˆØò 	!ˆCÜ&+¨C£jˆDK‰K˜Ÿ
™
Ñ#ØŸ*™* q™.¨D¯I©IÑ5ˆDŒJØz‰z˜Q‹Ø •	ñ		!r   c                óÚ  — |dk  rt        j                  dt        ¬«      S | j                  r| j                  n| j
                  }t        t        ||«      «      }| j
                  |z
  | j                  z  }||z   | j                  k  r | j                  |||z    j                  «       S | j                  |d }| j                  d||z   | j                  z   }t        j                  ||f«      S )z5Return the last ``n`` samples in chronological order.r   r   N)r   Úemptyr   r   r
   r   r	   Úminr   ÚcopyÚconcatenate)r   ÚnÚvalid_lengthÚstartÚpart1Úpart2s         r   Úget_lastzRingBuffer.get_last&   sÅ   € àŠ6Ü—8‘8˜A¤UÔ+Ð+Ø$(§I¢It—y’y°4·:±:ˆÜ”A|Ó$Ó%ˆØ—‘˜a‘ 4§9¡9Ñ,ˆØ1‰9˜Ÿ	™	Ò!Ø—;‘;˜u U¨Q¡YÐ/×4Ñ4Ó6Ð6à—K‘K  Ð'ˆEØ—K‘KÐ 9 5¨1¡9°·	±	Ñ"9Ð:ˆEÜ—>‘> 5¨% .Ó1Ð1r   c                óV   — | j                   j                  d«       d| _        d| _        y)z,Reset the buffer to its initial empty state.g        r   FN)r   Úfillr   r   )r   s    r   ÚclearzRingBuffer.clear4   s"   € à‰×Ñ˜ÔØˆŒ
Øˆ	r   N)r
   r	   ÚreturnÚNone)r   znp.ndarray | list[float]r+   r,   )r"   r	   r+   z
np.ndarray)r+   r,   )Ú__name__Ú
__module__Ú__qualname__Ú__doc__r   r   r'   r*   © r   r   r   r      s   „ ñó ó!ó2ôr   r   )r0   Ú
__future__r   Únumpyr   r   r1   r   r   ú<module>r4      s   ðñõ #ã ÷*ò *r   
------------------------------ END OF FILE ------------------------------

============================= util\calibration.py
# File: calibration.py (ext: .py
# Dir : util\
# Size: 856 bytes
# Time: 18/09/2025 10:43
============================= util\calibration.py
# util/calibration.py
from __future__ import annotations
import numpy as np
from core.state import AppState

def apply_global_and_scale(state: AppState, idx: int, y: np.ndarray) -> np.ndarray:
    """
    Uniform calibration used across the app:
      - If global baseline correction is enabled, subtract per-slot offset.
      - Apply per-channel multiplicative scale.
    Returns a 1-D float array (copy-safe for downstream code).
    """
    arr = np.asarray(y, dtype=float).ravel()
    if arr.size == 0:
        return arr
    try:
        if state.global_cal.enabled:
            arr = arr - float(state.global_cal.offsets[idx])
    except Exception:
        # Keep data unmodified on any mishap
        pass
    try:
        arr = float(state.channels[idx].cal.scale) * arr
    except Exception:
        pass
    return arr

------------------------------ END OF FILE ------------------------------

============================= util\ringbuf.py
# File: ringbuf.py (ext: .py
# Dir : util\
# Size: 1825 bytes
# Time: 16/09/2025 08:39
============================= util\ringbuf.py
"""A simple fixedâ€‘size ring buffer for numeric data.

The `RingBuffer` class stores a fixed number of the most recent samples in a
numpy array.  When the buffer fills up it silently overwrites the oldest
samples.  This is useful for implementing moving windows without dynamic
memory allocation.
"""

from __future__ import annotations

import numpy as np


class RingBuffer:
    """Fixedâ€‘length circular buffer for floats.

    Parameters
    ----------
    size : int
        Maximum number of elements to retain.
    """

    def __init__(self, size: int) -> None:
        self.size = int(size)
        self.buffer = np.zeros(self.size, dtype=float)
        self.index: int = 0
        self.full: bool = False

    def push(self, values: np.ndarray | list[float]) -> None:
        """Append one or more values to the buffer."""
        arr = np.asarray(values, dtype=float).ravel()
        for val in arr:
            self.buffer[self.index] = float(val)
            self.index = (self.index + 1) % self.size
            if self.index == 0:
                self.full = True

    def get_last(self, n: int) -> np.ndarray:
        """Return the last ``n`` samples in chronological order."""
        if n <= 0:
            return np.empty(0, dtype=float)
        valid_length = self.size if self.full else self.index
        n = int(min(n, valid_length))
        start = (self.index - n) % self.size
        if start + n <= self.size:
            return self.buffer[start:start + n].copy()
        else:
            part1 = self.buffer[start:]
            part2 = self.buffer[: (start + n) % self.size]
            return np.concatenate((part1, part2))

    def clear(self) -> None:
        """Reset the buffer to its initial empty state."""
        self.buffer.fill(0.0)
        self.index = 0
        self.full = False

------------------------------ END OF FILE ------------------------------

